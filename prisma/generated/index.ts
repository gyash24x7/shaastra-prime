// Code generated by Prisma (prisma@1.34.10). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export type Maybe<T> = T | undefined | null;

export interface Exists {
  channel: (where?: ChannelWhereInput) => Promise<boolean>;
  department: (where?: DepartmentWhereInput) => Promise<boolean>;
  media: (where?: MediaWhereInput) => Promise<boolean>;
  message: (where?: MessageWhereInput) => Promise<boolean>;
  reaction: (where?: ReactionWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  channel: (where: ChannelWhereUniqueInput) => ChannelNullablePromise;
  channels: (args?: {
    where?: ChannelWhereInput;
    orderBy?: ChannelOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Channel>;
  channelsConnection: (args?: {
    where?: ChannelWhereInput;
    orderBy?: ChannelOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ChannelConnectionPromise;
  department: (where: DepartmentWhereUniqueInput) => DepartmentNullablePromise;
  departments: (args?: {
    where?: DepartmentWhereInput;
    orderBy?: DepartmentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Department>;
  departmentsConnection: (args?: {
    where?: DepartmentWhereInput;
    orderBy?: DepartmentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => DepartmentConnectionPromise;
  media: (where: MediaWhereUniqueInput) => MediaNullablePromise;
  medias: (args?: {
    where?: MediaWhereInput;
    orderBy?: MediaOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Media>;
  mediasConnection: (args?: {
    where?: MediaWhereInput;
    orderBy?: MediaOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => MediaConnectionPromise;
  message: (where: MessageWhereUniqueInput) => MessageNullablePromise;
  messages: (args?: {
    where?: MessageWhereInput;
    orderBy?: MessageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Message>;
  messagesConnection: (args?: {
    where?: MessageWhereInput;
    orderBy?: MessageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => MessageConnectionPromise;
  reaction: (where: ReactionWhereUniqueInput) => ReactionNullablePromise;
  reactions: (args?: {
    where?: ReactionWhereInput;
    orderBy?: ReactionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Reaction>;
  reactionsConnection: (args?: {
    where?: ReactionWhereInput;
    orderBy?: ReactionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ReactionConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserNullablePromise;
  users: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<User>;
  usersConnection: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => UserConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createChannel: (data: ChannelCreateInput) => ChannelPromise;
  updateChannel: (args: {
    data: ChannelUpdateInput;
    where: ChannelWhereUniqueInput;
  }) => ChannelPromise;
  updateManyChannels: (args: {
    data: ChannelUpdateManyMutationInput;
    where?: ChannelWhereInput;
  }) => BatchPayloadPromise;
  upsertChannel: (args: {
    where: ChannelWhereUniqueInput;
    create: ChannelCreateInput;
    update: ChannelUpdateInput;
  }) => ChannelPromise;
  deleteChannel: (where: ChannelWhereUniqueInput) => ChannelPromise;
  deleteManyChannels: (where?: ChannelWhereInput) => BatchPayloadPromise;
  createDepartment: (data: DepartmentCreateInput) => DepartmentPromise;
  updateDepartment: (args: {
    data: DepartmentUpdateInput;
    where: DepartmentWhereUniqueInput;
  }) => DepartmentPromise;
  updateManyDepartments: (args: {
    data: DepartmentUpdateManyMutationInput;
    where?: DepartmentWhereInput;
  }) => BatchPayloadPromise;
  upsertDepartment: (args: {
    where: DepartmentWhereUniqueInput;
    create: DepartmentCreateInput;
    update: DepartmentUpdateInput;
  }) => DepartmentPromise;
  deleteDepartment: (where: DepartmentWhereUniqueInput) => DepartmentPromise;
  deleteManyDepartments: (where?: DepartmentWhereInput) => BatchPayloadPromise;
  createMedia: (data: MediaCreateInput) => MediaPromise;
  updateMedia: (args: {
    data: MediaUpdateInput;
    where: MediaWhereUniqueInput;
  }) => MediaPromise;
  updateManyMedias: (args: {
    data: MediaUpdateManyMutationInput;
    where?: MediaWhereInput;
  }) => BatchPayloadPromise;
  upsertMedia: (args: {
    where: MediaWhereUniqueInput;
    create: MediaCreateInput;
    update: MediaUpdateInput;
  }) => MediaPromise;
  deleteMedia: (where: MediaWhereUniqueInput) => MediaPromise;
  deleteManyMedias: (where?: MediaWhereInput) => BatchPayloadPromise;
  createMessage: (data: MessageCreateInput) => MessagePromise;
  updateMessage: (args: {
    data: MessageUpdateInput;
    where: MessageWhereUniqueInput;
  }) => MessagePromise;
  updateManyMessages: (args: {
    data: MessageUpdateManyMutationInput;
    where?: MessageWhereInput;
  }) => BatchPayloadPromise;
  upsertMessage: (args: {
    where: MessageWhereUniqueInput;
    create: MessageCreateInput;
    update: MessageUpdateInput;
  }) => MessagePromise;
  deleteMessage: (where: MessageWhereUniqueInput) => MessagePromise;
  deleteManyMessages: (where?: MessageWhereInput) => BatchPayloadPromise;
  createReaction: (data: ReactionCreateInput) => ReactionPromise;
  updateReaction: (args: {
    data: ReactionUpdateInput;
    where: ReactionWhereUniqueInput;
  }) => ReactionPromise;
  updateManyReactions: (args: {
    data: ReactionUpdateManyMutationInput;
    where?: ReactionWhereInput;
  }) => BatchPayloadPromise;
  upsertReaction: (args: {
    where: ReactionWhereUniqueInput;
    create: ReactionCreateInput;
    update: ReactionUpdateInput;
  }) => ReactionPromise;
  deleteReaction: (where: ReactionWhereUniqueInput) => ReactionPromise;
  deleteManyReactions: (where?: ReactionWhereInput) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (args: {
    data: UserUpdateInput;
    where: UserWhereUniqueInput;
  }) => UserPromise;
  updateManyUsers: (args: {
    data: UserUpdateManyMutationInput;
    where?: UserWhereInput;
  }) => BatchPayloadPromise;
  upsertUser: (args: {
    where: UserWhereUniqueInput;
    create: UserCreateInput;
    update: UserUpdateInput;
  }) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  channel: (
    where?: ChannelSubscriptionWhereInput
  ) => ChannelSubscriptionPayloadSubscription;
  department: (
    where?: DepartmentSubscriptionWhereInput
  ) => DepartmentSubscriptionPayloadSubscription;
  media: (
    where?: MediaSubscriptionWhereInput
  ) => MediaSubscriptionPayloadSubscription;
  message: (
    where?: MessageSubscriptionWhereInput
  ) => MessageSubscriptionPayloadSubscription;
  reaction: (
    where?: ReactionSubscriptionWhereInput
  ) => ReactionSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type AccessLevel = "COORD" | "CORE" | "COCAS" | "COCAD" | "HEAD";

export type MessageStatus = "SENT" | "DELIVERED" | "SEEN";

export type ReactionType = "LOVE" | "HAHA" | "CRY" | "LIKE";

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "rollNumber_ASC"
  | "rollNumber_DESC"
  | "email_ASC"
  | "email_DESC"
  | "password_ASC"
  | "password_DESC"
  | "mobile_ASC"
  | "mobile_DESC"
  | "upi_ASC"
  | "upi_DESC"
  | "about_ASC"
  | "about_DESC"
  | "profilePic_ASC"
  | "profilePic_DESC"
  | "coverPic_ASC"
  | "coverPic_DESC"
  | "role_ASC"
  | "role_DESC";

export type ChannelOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "description_ASC"
  | "description_DESC"
  | "archived_ASC"
  | "archived_DESC";

export type MessageOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "content_ASC"
  | "content_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "status_ASC"
  | "status_DESC"
  | "starred_ASC"
  | "starred_DESC";

export type ReactionOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "type_ASC"
  | "type_DESC";

export type MediaOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "url_ASC"
  | "url_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "status_ASC"
  | "status_DESC"
  | "starred_ASC"
  | "starred_DESC";

export type DepartmentOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type ChannelWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface UserWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  rollNumber?: Maybe<String>;
  rollNumber_not?: Maybe<String>;
  rollNumber_in?: Maybe<String[] | String>;
  rollNumber_not_in?: Maybe<String[] | String>;
  rollNumber_lt?: Maybe<String>;
  rollNumber_lte?: Maybe<String>;
  rollNumber_gt?: Maybe<String>;
  rollNumber_gte?: Maybe<String>;
  rollNumber_contains?: Maybe<String>;
  rollNumber_not_contains?: Maybe<String>;
  rollNumber_starts_with?: Maybe<String>;
  rollNumber_not_starts_with?: Maybe<String>;
  rollNumber_ends_with?: Maybe<String>;
  rollNumber_not_ends_with?: Maybe<String>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  password?: Maybe<String>;
  password_not?: Maybe<String>;
  password_in?: Maybe<String[] | String>;
  password_not_in?: Maybe<String[] | String>;
  password_lt?: Maybe<String>;
  password_lte?: Maybe<String>;
  password_gt?: Maybe<String>;
  password_gte?: Maybe<String>;
  password_contains?: Maybe<String>;
  password_not_contains?: Maybe<String>;
  password_starts_with?: Maybe<String>;
  password_not_starts_with?: Maybe<String>;
  password_ends_with?: Maybe<String>;
  password_not_ends_with?: Maybe<String>;
  mobile?: Maybe<String>;
  mobile_not?: Maybe<String>;
  mobile_in?: Maybe<String[] | String>;
  mobile_not_in?: Maybe<String[] | String>;
  mobile_lt?: Maybe<String>;
  mobile_lte?: Maybe<String>;
  mobile_gt?: Maybe<String>;
  mobile_gte?: Maybe<String>;
  mobile_contains?: Maybe<String>;
  mobile_not_contains?: Maybe<String>;
  mobile_starts_with?: Maybe<String>;
  mobile_not_starts_with?: Maybe<String>;
  mobile_ends_with?: Maybe<String>;
  mobile_not_ends_with?: Maybe<String>;
  upi?: Maybe<String>;
  upi_not?: Maybe<String>;
  upi_in?: Maybe<String[] | String>;
  upi_not_in?: Maybe<String[] | String>;
  upi_lt?: Maybe<String>;
  upi_lte?: Maybe<String>;
  upi_gt?: Maybe<String>;
  upi_gte?: Maybe<String>;
  upi_contains?: Maybe<String>;
  upi_not_contains?: Maybe<String>;
  upi_starts_with?: Maybe<String>;
  upi_not_starts_with?: Maybe<String>;
  upi_ends_with?: Maybe<String>;
  upi_not_ends_with?: Maybe<String>;
  about?: Maybe<String>;
  about_not?: Maybe<String>;
  about_in?: Maybe<String[] | String>;
  about_not_in?: Maybe<String[] | String>;
  about_lt?: Maybe<String>;
  about_lte?: Maybe<String>;
  about_gt?: Maybe<String>;
  about_gte?: Maybe<String>;
  about_contains?: Maybe<String>;
  about_not_contains?: Maybe<String>;
  about_starts_with?: Maybe<String>;
  about_not_starts_with?: Maybe<String>;
  about_ends_with?: Maybe<String>;
  about_not_ends_with?: Maybe<String>;
  profilePic?: Maybe<String>;
  profilePic_not?: Maybe<String>;
  profilePic_in?: Maybe<String[] | String>;
  profilePic_not_in?: Maybe<String[] | String>;
  profilePic_lt?: Maybe<String>;
  profilePic_lte?: Maybe<String>;
  profilePic_gt?: Maybe<String>;
  profilePic_gte?: Maybe<String>;
  profilePic_contains?: Maybe<String>;
  profilePic_not_contains?: Maybe<String>;
  profilePic_starts_with?: Maybe<String>;
  profilePic_not_starts_with?: Maybe<String>;
  profilePic_ends_with?: Maybe<String>;
  profilePic_not_ends_with?: Maybe<String>;
  coverPic?: Maybe<String>;
  coverPic_not?: Maybe<String>;
  coverPic_in?: Maybe<String[] | String>;
  coverPic_not_in?: Maybe<String[] | String>;
  coverPic_lt?: Maybe<String>;
  coverPic_lte?: Maybe<String>;
  coverPic_gt?: Maybe<String>;
  coverPic_gte?: Maybe<String>;
  coverPic_contains?: Maybe<String>;
  coverPic_not_contains?: Maybe<String>;
  coverPic_starts_with?: Maybe<String>;
  coverPic_not_starts_with?: Maybe<String>;
  coverPic_ends_with?: Maybe<String>;
  coverPic_not_ends_with?: Maybe<String>;
  role?: Maybe<AccessLevel>;
  role_not?: Maybe<AccessLevel>;
  role_in?: Maybe<AccessLevel[] | AccessLevel>;
  role_not_in?: Maybe<AccessLevel[] | AccessLevel>;
  department?: Maybe<DepartmentWhereInput>;
  channels_every?: Maybe<ChannelWhereInput>;
  channels_some?: Maybe<ChannelWhereInput>;
  channels_none?: Maybe<ChannelWhereInput>;
  messages_every?: Maybe<MessageWhereInput>;
  messages_some?: Maybe<MessageWhereInput>;
  messages_none?: Maybe<MessageWhereInput>;
  seenMessages_every?: Maybe<MessageWhereInput>;
  seenMessages_some?: Maybe<MessageWhereInput>;
  seenMessages_none?: Maybe<MessageWhereInput>;
  receivedMessages_every?: Maybe<MessageWhereInput>;
  receivedMessages_some?: Maybe<MessageWhereInput>;
  receivedMessages_none?: Maybe<MessageWhereInput>;
  seenMedia_every?: Maybe<MediaWhereInput>;
  seenMedia_some?: Maybe<MediaWhereInput>;
  seenMedia_none?: Maybe<MediaWhereInput>;
  receivedMedia_every?: Maybe<MediaWhereInput>;
  receivedMedia_some?: Maybe<MediaWhereInput>;
  receivedMedia_none?: Maybe<MediaWhereInput>;
  media_every?: Maybe<MediaWhereInput>;
  media_some?: Maybe<MediaWhereInput>;
  media_none?: Maybe<MediaWhereInput>;
  createdChannels_every?: Maybe<ChannelWhereInput>;
  createdChannels_some?: Maybe<ChannelWhereInput>;
  createdChannels_none?: Maybe<ChannelWhereInput>;
  taggedMessages_every?: Maybe<MessageWhereInput>;
  taggedMessages_some?: Maybe<MessageWhereInput>;
  taggedMessages_none?: Maybe<MessageWhereInput>;
  reactions_every?: Maybe<ReactionWhereInput>;
  reactions_some?: Maybe<ReactionWhereInput>;
  reactions_none?: Maybe<ReactionWhereInput>;
  AND?: Maybe<UserWhereInput[] | UserWhereInput>;
  OR?: Maybe<UserWhereInput[] | UserWhereInput>;
  NOT?: Maybe<UserWhereInput[] | UserWhereInput>;
}

export interface DepartmentWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  members_every?: Maybe<UserWhereInput>;
  members_some?: Maybe<UserWhereInput>;
  members_none?: Maybe<UserWhereInput>;
  AND?: Maybe<DepartmentWhereInput[] | DepartmentWhereInput>;
  OR?: Maybe<DepartmentWhereInput[] | DepartmentWhereInput>;
  NOT?: Maybe<DepartmentWhereInput[] | DepartmentWhereInput>;
}

export interface ChannelWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  archived?: Maybe<Boolean>;
  archived_not?: Maybe<Boolean>;
  members_every?: Maybe<UserWhereInput>;
  members_some?: Maybe<UserWhereInput>;
  members_none?: Maybe<UserWhereInput>;
  messages_every?: Maybe<MessageWhereInput>;
  messages_some?: Maybe<MessageWhereInput>;
  messages_none?: Maybe<MessageWhereInput>;
  media_every?: Maybe<MediaWhereInput>;
  media_some?: Maybe<MediaWhereInput>;
  media_none?: Maybe<MediaWhereInput>;
  createdBy?: Maybe<UserWhereInput>;
  AND?: Maybe<ChannelWhereInput[] | ChannelWhereInput>;
  OR?: Maybe<ChannelWhereInput[] | ChannelWhereInput>;
  NOT?: Maybe<ChannelWhereInput[] | ChannelWhereInput>;
}

export interface MessageWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  content?: Maybe<String>;
  content_not?: Maybe<String>;
  content_in?: Maybe<String[] | String>;
  content_not_in?: Maybe<String[] | String>;
  content_lt?: Maybe<String>;
  content_lte?: Maybe<String>;
  content_gt?: Maybe<String>;
  content_gte?: Maybe<String>;
  content_contains?: Maybe<String>;
  content_not_contains?: Maybe<String>;
  content_starts_with?: Maybe<String>;
  content_not_starts_with?: Maybe<String>;
  content_ends_with?: Maybe<String>;
  content_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  status?: Maybe<MessageStatus>;
  status_not?: Maybe<MessageStatus>;
  status_in?: Maybe<MessageStatus[] | MessageStatus>;
  status_not_in?: Maybe<MessageStatus[] | MessageStatus>;
  starred?: Maybe<Boolean>;
  starred_not?: Maybe<Boolean>;
  createdBy?: Maybe<UserWhereInput>;
  channel?: Maybe<ChannelWhereInput>;
  seenBy_every?: Maybe<UserWhereInput>;
  seenBy_some?: Maybe<UserWhereInput>;
  seenBy_none?: Maybe<UserWhereInput>;
  receivedBy_every?: Maybe<UserWhereInput>;
  receivedBy_some?: Maybe<UserWhereInput>;
  receivedBy_none?: Maybe<UserWhereInput>;
  tagged_every?: Maybe<UserWhereInput>;
  tagged_some?: Maybe<UserWhereInput>;
  tagged_none?: Maybe<UserWhereInput>;
  reactions_every?: Maybe<ReactionWhereInput>;
  reactions_some?: Maybe<ReactionWhereInput>;
  reactions_none?: Maybe<ReactionWhereInput>;
  AND?: Maybe<MessageWhereInput[] | MessageWhereInput>;
  OR?: Maybe<MessageWhereInput[] | MessageWhereInput>;
  NOT?: Maybe<MessageWhereInput[] | MessageWhereInput>;
}

export interface ReactionWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  type?: Maybe<ReactionType>;
  type_not?: Maybe<ReactionType>;
  type_in?: Maybe<ReactionType[] | ReactionType>;
  type_not_in?: Maybe<ReactionType[] | ReactionType>;
  by?: Maybe<UserWhereInput>;
  message?: Maybe<MessageWhereInput>;
  AND?: Maybe<ReactionWhereInput[] | ReactionWhereInput>;
  OR?: Maybe<ReactionWhereInput[] | ReactionWhereInput>;
  NOT?: Maybe<ReactionWhereInput[] | ReactionWhereInput>;
}

export interface MediaWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  url?: Maybe<String>;
  url_not?: Maybe<String>;
  url_in?: Maybe<String[] | String>;
  url_not_in?: Maybe<String[] | String>;
  url_lt?: Maybe<String>;
  url_lte?: Maybe<String>;
  url_gt?: Maybe<String>;
  url_gte?: Maybe<String>;
  url_contains?: Maybe<String>;
  url_not_contains?: Maybe<String>;
  url_starts_with?: Maybe<String>;
  url_not_starts_with?: Maybe<String>;
  url_ends_with?: Maybe<String>;
  url_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  status?: Maybe<MessageStatus>;
  status_not?: Maybe<MessageStatus>;
  status_in?: Maybe<MessageStatus[] | MessageStatus>;
  status_not_in?: Maybe<MessageStatus[] | MessageStatus>;
  starred?: Maybe<Boolean>;
  starred_not?: Maybe<Boolean>;
  uploadedBy?: Maybe<UserWhereInput>;
  channel?: Maybe<ChannelWhereInput>;
  seenBy_every?: Maybe<UserWhereInput>;
  seenBy_some?: Maybe<UserWhereInput>;
  seenBy_none?: Maybe<UserWhereInput>;
  receivedBy_every?: Maybe<UserWhereInput>;
  receivedBy_some?: Maybe<UserWhereInput>;
  receivedBy_none?: Maybe<UserWhereInput>;
  AND?: Maybe<MediaWhereInput[] | MediaWhereInput>;
  OR?: Maybe<MediaWhereInput[] | MediaWhereInput>;
  NOT?: Maybe<MediaWhereInput[] | MediaWhereInput>;
}

export type DepartmentWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type MediaWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type MessageWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type ReactionWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type UserWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  rollNumber?: Maybe<String>;
  email?: Maybe<String>;
  mobile?: Maybe<String>;
}>;

export interface ChannelCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  description: String;
  archived?: Maybe<Boolean>;
  members?: Maybe<UserCreateManyWithoutChannelsInput>;
  messages?: Maybe<MessageCreateManyWithoutChannelInput>;
  media?: Maybe<MediaCreateManyWithoutChannelInput>;
  createdBy: UserCreateOneWithoutCreatedChannelsInput;
}

export interface UserCreateManyWithoutChannelsInput {
  create?: Maybe<
    UserCreateWithoutChannelsInput[] | UserCreateWithoutChannelsInput
  >;
  connect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
}

export interface UserCreateWithoutChannelsInput {
  id?: Maybe<ID_Input>;
  name: String;
  rollNumber: String;
  email: String;
  password: String;
  mobile: String;
  upi: String;
  about?: Maybe<String>;
  profilePic: String;
  coverPic: String;
  role?: Maybe<AccessLevel>;
  department?: Maybe<DepartmentCreateOneWithoutMembersInput>;
  messages?: Maybe<MessageCreateManyWithoutCreatedByInput>;
  seenMessages?: Maybe<MessageCreateManyWithoutSeenByInput>;
  receivedMessages?: Maybe<MessageCreateManyInput>;
  seenMedia?: Maybe<MediaCreateManyWithoutSeenByInput>;
  receivedMedia?: Maybe<MediaCreateManyWithoutReceivedByInput>;
  media?: Maybe<MediaCreateManyWithoutUploadedByInput>;
  createdChannels?: Maybe<ChannelCreateManyWithoutCreatedByInput>;
  taggedMessages?: Maybe<MessageCreateManyWithoutTaggedInput>;
  reactions?: Maybe<ReactionCreateManyWithoutByInput>;
}

export interface DepartmentCreateOneWithoutMembersInput {
  create?: Maybe<DepartmentCreateWithoutMembersInput>;
  connect?: Maybe<DepartmentWhereUniqueInput>;
}

export interface DepartmentCreateWithoutMembersInput {
  id?: Maybe<ID_Input>;
  name: String;
  subDepartments?: Maybe<DepartmentCreatesubDepartmentsInput>;
}

export interface DepartmentCreatesubDepartmentsInput {
  set?: Maybe<String[] | String>;
}

export interface MessageCreateManyWithoutCreatedByInput {
  create?: Maybe<
    MessageCreateWithoutCreatedByInput[] | MessageCreateWithoutCreatedByInput
  >;
  connect?: Maybe<MessageWhereUniqueInput[] | MessageWhereUniqueInput>;
}

export interface MessageCreateWithoutCreatedByInput {
  id?: Maybe<ID_Input>;
  content: String;
  status?: Maybe<MessageStatus>;
  starred?: Maybe<Boolean>;
  channel: ChannelCreateOneWithoutMessagesInput;
  seenBy?: Maybe<UserCreateManyWithoutSeenMessagesInput>;
  receivedBy?: Maybe<UserCreateManyInput>;
  tagged?: Maybe<UserCreateManyWithoutTaggedMessagesInput>;
  reactions?: Maybe<ReactionCreateManyWithoutMessageInput>;
}

export interface ChannelCreateOneWithoutMessagesInput {
  create?: Maybe<ChannelCreateWithoutMessagesInput>;
  connect?: Maybe<ChannelWhereUniqueInput>;
}

export interface ChannelCreateWithoutMessagesInput {
  id?: Maybe<ID_Input>;
  name: String;
  description: String;
  archived?: Maybe<Boolean>;
  members?: Maybe<UserCreateManyWithoutChannelsInput>;
  media?: Maybe<MediaCreateManyWithoutChannelInput>;
  createdBy: UserCreateOneWithoutCreatedChannelsInput;
}

export interface MediaCreateManyWithoutChannelInput {
  create?: Maybe<
    MediaCreateWithoutChannelInput[] | MediaCreateWithoutChannelInput
  >;
  connect?: Maybe<MediaWhereUniqueInput[] | MediaWhereUniqueInput>;
}

export interface MediaCreateWithoutChannelInput {
  id?: Maybe<ID_Input>;
  url: String;
  status?: Maybe<MessageStatus>;
  starred?: Maybe<Boolean>;
  uploadedBy: UserCreateOneWithoutMediaInput;
  seenBy?: Maybe<UserCreateManyWithoutSeenMediaInput>;
  receivedBy?: Maybe<UserCreateManyWithoutReceivedMediaInput>;
}

export interface UserCreateOneWithoutMediaInput {
  create?: Maybe<UserCreateWithoutMediaInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserCreateWithoutMediaInput {
  id?: Maybe<ID_Input>;
  name: String;
  rollNumber: String;
  email: String;
  password: String;
  mobile: String;
  upi: String;
  about?: Maybe<String>;
  profilePic: String;
  coverPic: String;
  role?: Maybe<AccessLevel>;
  department?: Maybe<DepartmentCreateOneWithoutMembersInput>;
  channels?: Maybe<ChannelCreateManyWithoutMembersInput>;
  messages?: Maybe<MessageCreateManyWithoutCreatedByInput>;
  seenMessages?: Maybe<MessageCreateManyWithoutSeenByInput>;
  receivedMessages?: Maybe<MessageCreateManyInput>;
  seenMedia?: Maybe<MediaCreateManyWithoutSeenByInput>;
  receivedMedia?: Maybe<MediaCreateManyWithoutReceivedByInput>;
  createdChannels?: Maybe<ChannelCreateManyWithoutCreatedByInput>;
  taggedMessages?: Maybe<MessageCreateManyWithoutTaggedInput>;
  reactions?: Maybe<ReactionCreateManyWithoutByInput>;
}

export interface ChannelCreateManyWithoutMembersInput {
  create?: Maybe<
    ChannelCreateWithoutMembersInput[] | ChannelCreateWithoutMembersInput
  >;
  connect?: Maybe<ChannelWhereUniqueInput[] | ChannelWhereUniqueInput>;
}

export interface ChannelCreateWithoutMembersInput {
  id?: Maybe<ID_Input>;
  name: String;
  description: String;
  archived?: Maybe<Boolean>;
  messages?: Maybe<MessageCreateManyWithoutChannelInput>;
  media?: Maybe<MediaCreateManyWithoutChannelInput>;
  createdBy: UserCreateOneWithoutCreatedChannelsInput;
}

export interface MessageCreateManyWithoutChannelInput {
  create?: Maybe<
    MessageCreateWithoutChannelInput[] | MessageCreateWithoutChannelInput
  >;
  connect?: Maybe<MessageWhereUniqueInput[] | MessageWhereUniqueInput>;
}

export interface MessageCreateWithoutChannelInput {
  id?: Maybe<ID_Input>;
  content: String;
  status?: Maybe<MessageStatus>;
  starred?: Maybe<Boolean>;
  createdBy: UserCreateOneWithoutMessagesInput;
  seenBy?: Maybe<UserCreateManyWithoutSeenMessagesInput>;
  receivedBy?: Maybe<UserCreateManyInput>;
  tagged?: Maybe<UserCreateManyWithoutTaggedMessagesInput>;
  reactions?: Maybe<ReactionCreateManyWithoutMessageInput>;
}

export interface UserCreateOneWithoutMessagesInput {
  create?: Maybe<UserCreateWithoutMessagesInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserCreateWithoutMessagesInput {
  id?: Maybe<ID_Input>;
  name: String;
  rollNumber: String;
  email: String;
  password: String;
  mobile: String;
  upi: String;
  about?: Maybe<String>;
  profilePic: String;
  coverPic: String;
  role?: Maybe<AccessLevel>;
  department?: Maybe<DepartmentCreateOneWithoutMembersInput>;
  channels?: Maybe<ChannelCreateManyWithoutMembersInput>;
  seenMessages?: Maybe<MessageCreateManyWithoutSeenByInput>;
  receivedMessages?: Maybe<MessageCreateManyInput>;
  seenMedia?: Maybe<MediaCreateManyWithoutSeenByInput>;
  receivedMedia?: Maybe<MediaCreateManyWithoutReceivedByInput>;
  media?: Maybe<MediaCreateManyWithoutUploadedByInput>;
  createdChannels?: Maybe<ChannelCreateManyWithoutCreatedByInput>;
  taggedMessages?: Maybe<MessageCreateManyWithoutTaggedInput>;
  reactions?: Maybe<ReactionCreateManyWithoutByInput>;
}

export interface MessageCreateManyWithoutSeenByInput {
  create?: Maybe<
    MessageCreateWithoutSeenByInput[] | MessageCreateWithoutSeenByInput
  >;
  connect?: Maybe<MessageWhereUniqueInput[] | MessageWhereUniqueInput>;
}

export interface MessageCreateWithoutSeenByInput {
  id?: Maybe<ID_Input>;
  content: String;
  status?: Maybe<MessageStatus>;
  starred?: Maybe<Boolean>;
  createdBy: UserCreateOneWithoutMessagesInput;
  channel: ChannelCreateOneWithoutMessagesInput;
  receivedBy?: Maybe<UserCreateManyInput>;
  tagged?: Maybe<UserCreateManyWithoutTaggedMessagesInput>;
  reactions?: Maybe<ReactionCreateManyWithoutMessageInput>;
}

export interface UserCreateManyInput {
  create?: Maybe<UserCreateInput[] | UserCreateInput>;
  connect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
}

export interface UserCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  rollNumber: String;
  email: String;
  password: String;
  mobile: String;
  upi: String;
  about?: Maybe<String>;
  profilePic: String;
  coverPic: String;
  role?: Maybe<AccessLevel>;
  department?: Maybe<DepartmentCreateOneWithoutMembersInput>;
  channels?: Maybe<ChannelCreateManyWithoutMembersInput>;
  messages?: Maybe<MessageCreateManyWithoutCreatedByInput>;
  seenMessages?: Maybe<MessageCreateManyWithoutSeenByInput>;
  receivedMessages?: Maybe<MessageCreateManyInput>;
  seenMedia?: Maybe<MediaCreateManyWithoutSeenByInput>;
  receivedMedia?: Maybe<MediaCreateManyWithoutReceivedByInput>;
  media?: Maybe<MediaCreateManyWithoutUploadedByInput>;
  createdChannels?: Maybe<ChannelCreateManyWithoutCreatedByInput>;
  taggedMessages?: Maybe<MessageCreateManyWithoutTaggedInput>;
  reactions?: Maybe<ReactionCreateManyWithoutByInput>;
}

export interface MessageCreateManyInput {
  create?: Maybe<MessageCreateInput[] | MessageCreateInput>;
  connect?: Maybe<MessageWhereUniqueInput[] | MessageWhereUniqueInput>;
}

export interface MessageCreateInput {
  id?: Maybe<ID_Input>;
  content: String;
  status?: Maybe<MessageStatus>;
  starred?: Maybe<Boolean>;
  createdBy: UserCreateOneWithoutMessagesInput;
  channel: ChannelCreateOneWithoutMessagesInput;
  seenBy?: Maybe<UserCreateManyWithoutSeenMessagesInput>;
  receivedBy?: Maybe<UserCreateManyInput>;
  tagged?: Maybe<UserCreateManyWithoutTaggedMessagesInput>;
  reactions?: Maybe<ReactionCreateManyWithoutMessageInput>;
}

export interface UserCreateManyWithoutSeenMessagesInput {
  create?: Maybe<
    UserCreateWithoutSeenMessagesInput[] | UserCreateWithoutSeenMessagesInput
  >;
  connect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
}

export interface UserCreateWithoutSeenMessagesInput {
  id?: Maybe<ID_Input>;
  name: String;
  rollNumber: String;
  email: String;
  password: String;
  mobile: String;
  upi: String;
  about?: Maybe<String>;
  profilePic: String;
  coverPic: String;
  role?: Maybe<AccessLevel>;
  department?: Maybe<DepartmentCreateOneWithoutMembersInput>;
  channels?: Maybe<ChannelCreateManyWithoutMembersInput>;
  messages?: Maybe<MessageCreateManyWithoutCreatedByInput>;
  receivedMessages?: Maybe<MessageCreateManyInput>;
  seenMedia?: Maybe<MediaCreateManyWithoutSeenByInput>;
  receivedMedia?: Maybe<MediaCreateManyWithoutReceivedByInput>;
  media?: Maybe<MediaCreateManyWithoutUploadedByInput>;
  createdChannels?: Maybe<ChannelCreateManyWithoutCreatedByInput>;
  taggedMessages?: Maybe<MessageCreateManyWithoutTaggedInput>;
  reactions?: Maybe<ReactionCreateManyWithoutByInput>;
}

export interface MediaCreateManyWithoutSeenByInput {
  create?: Maybe<
    MediaCreateWithoutSeenByInput[] | MediaCreateWithoutSeenByInput
  >;
  connect?: Maybe<MediaWhereUniqueInput[] | MediaWhereUniqueInput>;
}

export interface MediaCreateWithoutSeenByInput {
  id?: Maybe<ID_Input>;
  url: String;
  status?: Maybe<MessageStatus>;
  starred?: Maybe<Boolean>;
  uploadedBy: UserCreateOneWithoutMediaInput;
  channel: ChannelCreateOneWithoutMediaInput;
  receivedBy?: Maybe<UserCreateManyWithoutReceivedMediaInput>;
}

export interface ChannelCreateOneWithoutMediaInput {
  create?: Maybe<ChannelCreateWithoutMediaInput>;
  connect?: Maybe<ChannelWhereUniqueInput>;
}

export interface ChannelCreateWithoutMediaInput {
  id?: Maybe<ID_Input>;
  name: String;
  description: String;
  archived?: Maybe<Boolean>;
  members?: Maybe<UserCreateManyWithoutChannelsInput>;
  messages?: Maybe<MessageCreateManyWithoutChannelInput>;
  createdBy: UserCreateOneWithoutCreatedChannelsInput;
}

export interface UserCreateOneWithoutCreatedChannelsInput {
  create?: Maybe<UserCreateWithoutCreatedChannelsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserCreateWithoutCreatedChannelsInput {
  id?: Maybe<ID_Input>;
  name: String;
  rollNumber: String;
  email: String;
  password: String;
  mobile: String;
  upi: String;
  about?: Maybe<String>;
  profilePic: String;
  coverPic: String;
  role?: Maybe<AccessLevel>;
  department?: Maybe<DepartmentCreateOneWithoutMembersInput>;
  channels?: Maybe<ChannelCreateManyWithoutMembersInput>;
  messages?: Maybe<MessageCreateManyWithoutCreatedByInput>;
  seenMessages?: Maybe<MessageCreateManyWithoutSeenByInput>;
  receivedMessages?: Maybe<MessageCreateManyInput>;
  seenMedia?: Maybe<MediaCreateManyWithoutSeenByInput>;
  receivedMedia?: Maybe<MediaCreateManyWithoutReceivedByInput>;
  media?: Maybe<MediaCreateManyWithoutUploadedByInput>;
  taggedMessages?: Maybe<MessageCreateManyWithoutTaggedInput>;
  reactions?: Maybe<ReactionCreateManyWithoutByInput>;
}

export interface MediaCreateManyWithoutReceivedByInput {
  create?: Maybe<
    MediaCreateWithoutReceivedByInput[] | MediaCreateWithoutReceivedByInput
  >;
  connect?: Maybe<MediaWhereUniqueInput[] | MediaWhereUniqueInput>;
}

export interface MediaCreateWithoutReceivedByInput {
  id?: Maybe<ID_Input>;
  url: String;
  status?: Maybe<MessageStatus>;
  starred?: Maybe<Boolean>;
  uploadedBy: UserCreateOneWithoutMediaInput;
  channel: ChannelCreateOneWithoutMediaInput;
  seenBy?: Maybe<UserCreateManyWithoutSeenMediaInput>;
}

export interface UserCreateManyWithoutSeenMediaInput {
  create?: Maybe<
    UserCreateWithoutSeenMediaInput[] | UserCreateWithoutSeenMediaInput
  >;
  connect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
}

export interface UserCreateWithoutSeenMediaInput {
  id?: Maybe<ID_Input>;
  name: String;
  rollNumber: String;
  email: String;
  password: String;
  mobile: String;
  upi: String;
  about?: Maybe<String>;
  profilePic: String;
  coverPic: String;
  role?: Maybe<AccessLevel>;
  department?: Maybe<DepartmentCreateOneWithoutMembersInput>;
  channels?: Maybe<ChannelCreateManyWithoutMembersInput>;
  messages?: Maybe<MessageCreateManyWithoutCreatedByInput>;
  seenMessages?: Maybe<MessageCreateManyWithoutSeenByInput>;
  receivedMessages?: Maybe<MessageCreateManyInput>;
  receivedMedia?: Maybe<MediaCreateManyWithoutReceivedByInput>;
  media?: Maybe<MediaCreateManyWithoutUploadedByInput>;
  createdChannels?: Maybe<ChannelCreateManyWithoutCreatedByInput>;
  taggedMessages?: Maybe<MessageCreateManyWithoutTaggedInput>;
  reactions?: Maybe<ReactionCreateManyWithoutByInput>;
}

export interface MediaCreateManyWithoutUploadedByInput {
  create?: Maybe<
    MediaCreateWithoutUploadedByInput[] | MediaCreateWithoutUploadedByInput
  >;
  connect?: Maybe<MediaWhereUniqueInput[] | MediaWhereUniqueInput>;
}

export interface MediaCreateWithoutUploadedByInput {
  id?: Maybe<ID_Input>;
  url: String;
  status?: Maybe<MessageStatus>;
  starred?: Maybe<Boolean>;
  channel: ChannelCreateOneWithoutMediaInput;
  seenBy?: Maybe<UserCreateManyWithoutSeenMediaInput>;
  receivedBy?: Maybe<UserCreateManyWithoutReceivedMediaInput>;
}

export interface UserCreateManyWithoutReceivedMediaInput {
  create?: Maybe<
    UserCreateWithoutReceivedMediaInput[] | UserCreateWithoutReceivedMediaInput
  >;
  connect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
}

export interface UserCreateWithoutReceivedMediaInput {
  id?: Maybe<ID_Input>;
  name: String;
  rollNumber: String;
  email: String;
  password: String;
  mobile: String;
  upi: String;
  about?: Maybe<String>;
  profilePic: String;
  coverPic: String;
  role?: Maybe<AccessLevel>;
  department?: Maybe<DepartmentCreateOneWithoutMembersInput>;
  channels?: Maybe<ChannelCreateManyWithoutMembersInput>;
  messages?: Maybe<MessageCreateManyWithoutCreatedByInput>;
  seenMessages?: Maybe<MessageCreateManyWithoutSeenByInput>;
  receivedMessages?: Maybe<MessageCreateManyInput>;
  seenMedia?: Maybe<MediaCreateManyWithoutSeenByInput>;
  media?: Maybe<MediaCreateManyWithoutUploadedByInput>;
  createdChannels?: Maybe<ChannelCreateManyWithoutCreatedByInput>;
  taggedMessages?: Maybe<MessageCreateManyWithoutTaggedInput>;
  reactions?: Maybe<ReactionCreateManyWithoutByInput>;
}

export interface ChannelCreateManyWithoutCreatedByInput {
  create?: Maybe<
    ChannelCreateWithoutCreatedByInput[] | ChannelCreateWithoutCreatedByInput
  >;
  connect?: Maybe<ChannelWhereUniqueInput[] | ChannelWhereUniqueInput>;
}

export interface ChannelCreateWithoutCreatedByInput {
  id?: Maybe<ID_Input>;
  name: String;
  description: String;
  archived?: Maybe<Boolean>;
  members?: Maybe<UserCreateManyWithoutChannelsInput>;
  messages?: Maybe<MessageCreateManyWithoutChannelInput>;
  media?: Maybe<MediaCreateManyWithoutChannelInput>;
}

export interface MessageCreateManyWithoutTaggedInput {
  create?: Maybe<
    MessageCreateWithoutTaggedInput[] | MessageCreateWithoutTaggedInput
  >;
  connect?: Maybe<MessageWhereUniqueInput[] | MessageWhereUniqueInput>;
}

export interface MessageCreateWithoutTaggedInput {
  id?: Maybe<ID_Input>;
  content: String;
  status?: Maybe<MessageStatus>;
  starred?: Maybe<Boolean>;
  createdBy: UserCreateOneWithoutMessagesInput;
  channel: ChannelCreateOneWithoutMessagesInput;
  seenBy?: Maybe<UserCreateManyWithoutSeenMessagesInput>;
  receivedBy?: Maybe<UserCreateManyInput>;
  reactions?: Maybe<ReactionCreateManyWithoutMessageInput>;
}

export interface ReactionCreateManyWithoutMessageInput {
  create?: Maybe<
    ReactionCreateWithoutMessageInput[] | ReactionCreateWithoutMessageInput
  >;
  connect?: Maybe<ReactionWhereUniqueInput[] | ReactionWhereUniqueInput>;
}

export interface ReactionCreateWithoutMessageInput {
  id?: Maybe<ID_Input>;
  type: ReactionType;
  by: UserCreateOneWithoutReactionsInput;
}

export interface UserCreateOneWithoutReactionsInput {
  create?: Maybe<UserCreateWithoutReactionsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserCreateWithoutReactionsInput {
  id?: Maybe<ID_Input>;
  name: String;
  rollNumber: String;
  email: String;
  password: String;
  mobile: String;
  upi: String;
  about?: Maybe<String>;
  profilePic: String;
  coverPic: String;
  role?: Maybe<AccessLevel>;
  department?: Maybe<DepartmentCreateOneWithoutMembersInput>;
  channels?: Maybe<ChannelCreateManyWithoutMembersInput>;
  messages?: Maybe<MessageCreateManyWithoutCreatedByInput>;
  seenMessages?: Maybe<MessageCreateManyWithoutSeenByInput>;
  receivedMessages?: Maybe<MessageCreateManyInput>;
  seenMedia?: Maybe<MediaCreateManyWithoutSeenByInput>;
  receivedMedia?: Maybe<MediaCreateManyWithoutReceivedByInput>;
  media?: Maybe<MediaCreateManyWithoutUploadedByInput>;
  createdChannels?: Maybe<ChannelCreateManyWithoutCreatedByInput>;
  taggedMessages?: Maybe<MessageCreateManyWithoutTaggedInput>;
}

export interface ReactionCreateManyWithoutByInput {
  create?: Maybe<ReactionCreateWithoutByInput[] | ReactionCreateWithoutByInput>;
  connect?: Maybe<ReactionWhereUniqueInput[] | ReactionWhereUniqueInput>;
}

export interface ReactionCreateWithoutByInput {
  id?: Maybe<ID_Input>;
  type: ReactionType;
  message: MessageCreateOneWithoutReactionsInput;
}

export interface MessageCreateOneWithoutReactionsInput {
  create?: Maybe<MessageCreateWithoutReactionsInput>;
  connect?: Maybe<MessageWhereUniqueInput>;
}

export interface MessageCreateWithoutReactionsInput {
  id?: Maybe<ID_Input>;
  content: String;
  status?: Maybe<MessageStatus>;
  starred?: Maybe<Boolean>;
  createdBy: UserCreateOneWithoutMessagesInput;
  channel: ChannelCreateOneWithoutMessagesInput;
  seenBy?: Maybe<UserCreateManyWithoutSeenMessagesInput>;
  receivedBy?: Maybe<UserCreateManyInput>;
  tagged?: Maybe<UserCreateManyWithoutTaggedMessagesInput>;
}

export interface UserCreateManyWithoutTaggedMessagesInput {
  create?: Maybe<
    | UserCreateWithoutTaggedMessagesInput[]
    | UserCreateWithoutTaggedMessagesInput
  >;
  connect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
}

export interface UserCreateWithoutTaggedMessagesInput {
  id?: Maybe<ID_Input>;
  name: String;
  rollNumber: String;
  email: String;
  password: String;
  mobile: String;
  upi: String;
  about?: Maybe<String>;
  profilePic: String;
  coverPic: String;
  role?: Maybe<AccessLevel>;
  department?: Maybe<DepartmentCreateOneWithoutMembersInput>;
  channels?: Maybe<ChannelCreateManyWithoutMembersInput>;
  messages?: Maybe<MessageCreateManyWithoutCreatedByInput>;
  seenMessages?: Maybe<MessageCreateManyWithoutSeenByInput>;
  receivedMessages?: Maybe<MessageCreateManyInput>;
  seenMedia?: Maybe<MediaCreateManyWithoutSeenByInput>;
  receivedMedia?: Maybe<MediaCreateManyWithoutReceivedByInput>;
  media?: Maybe<MediaCreateManyWithoutUploadedByInput>;
  createdChannels?: Maybe<ChannelCreateManyWithoutCreatedByInput>;
  reactions?: Maybe<ReactionCreateManyWithoutByInput>;
}

export interface ChannelUpdateInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  archived?: Maybe<Boolean>;
  members?: Maybe<UserUpdateManyWithoutChannelsInput>;
  messages?: Maybe<MessageUpdateManyWithoutChannelInput>;
  media?: Maybe<MediaUpdateManyWithoutChannelInput>;
  createdBy?: Maybe<UserUpdateOneRequiredWithoutCreatedChannelsInput>;
}

export interface UserUpdateManyWithoutChannelsInput {
  create?: Maybe<
    UserCreateWithoutChannelsInput[] | UserCreateWithoutChannelsInput
  >;
  delete?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  connect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  set?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  disconnect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  update?: Maybe<
    | UserUpdateWithWhereUniqueWithoutChannelsInput[]
    | UserUpdateWithWhereUniqueWithoutChannelsInput
  >;
  upsert?: Maybe<
    | UserUpsertWithWhereUniqueWithoutChannelsInput[]
    | UserUpsertWithWhereUniqueWithoutChannelsInput
  >;
  deleteMany?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
  updateMany?: Maybe<
    UserUpdateManyWithWhereNestedInput[] | UserUpdateManyWithWhereNestedInput
  >;
}

export interface UserUpdateWithWhereUniqueWithoutChannelsInput {
  where: UserWhereUniqueInput;
  data: UserUpdateWithoutChannelsDataInput;
}

export interface UserUpdateWithoutChannelsDataInput {
  name?: Maybe<String>;
  rollNumber?: Maybe<String>;
  email?: Maybe<String>;
  password?: Maybe<String>;
  mobile?: Maybe<String>;
  upi?: Maybe<String>;
  about?: Maybe<String>;
  profilePic?: Maybe<String>;
  coverPic?: Maybe<String>;
  role?: Maybe<AccessLevel>;
  department?: Maybe<DepartmentUpdateOneWithoutMembersInput>;
  messages?: Maybe<MessageUpdateManyWithoutCreatedByInput>;
  seenMessages?: Maybe<MessageUpdateManyWithoutSeenByInput>;
  receivedMessages?: Maybe<MessageUpdateManyInput>;
  seenMedia?: Maybe<MediaUpdateManyWithoutSeenByInput>;
  receivedMedia?: Maybe<MediaUpdateManyWithoutReceivedByInput>;
  media?: Maybe<MediaUpdateManyWithoutUploadedByInput>;
  createdChannels?: Maybe<ChannelUpdateManyWithoutCreatedByInput>;
  taggedMessages?: Maybe<MessageUpdateManyWithoutTaggedInput>;
  reactions?: Maybe<ReactionUpdateManyWithoutByInput>;
}

export interface DepartmentUpdateOneWithoutMembersInput {
  create?: Maybe<DepartmentCreateWithoutMembersInput>;
  update?: Maybe<DepartmentUpdateWithoutMembersDataInput>;
  upsert?: Maybe<DepartmentUpsertWithoutMembersInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<DepartmentWhereUniqueInput>;
}

export interface DepartmentUpdateWithoutMembersDataInput {
  name?: Maybe<String>;
  subDepartments?: Maybe<DepartmentUpdatesubDepartmentsInput>;
}

export interface DepartmentUpdatesubDepartmentsInput {
  set?: Maybe<String[] | String>;
}

export interface DepartmentUpsertWithoutMembersInput {
  update: DepartmentUpdateWithoutMembersDataInput;
  create: DepartmentCreateWithoutMembersInput;
}

export interface MessageUpdateManyWithoutCreatedByInput {
  create?: Maybe<
    MessageCreateWithoutCreatedByInput[] | MessageCreateWithoutCreatedByInput
  >;
  delete?: Maybe<MessageWhereUniqueInput[] | MessageWhereUniqueInput>;
  connect?: Maybe<MessageWhereUniqueInput[] | MessageWhereUniqueInput>;
  set?: Maybe<MessageWhereUniqueInput[] | MessageWhereUniqueInput>;
  disconnect?: Maybe<MessageWhereUniqueInput[] | MessageWhereUniqueInput>;
  update?: Maybe<
    | MessageUpdateWithWhereUniqueWithoutCreatedByInput[]
    | MessageUpdateWithWhereUniqueWithoutCreatedByInput
  >;
  upsert?: Maybe<
    | MessageUpsertWithWhereUniqueWithoutCreatedByInput[]
    | MessageUpsertWithWhereUniqueWithoutCreatedByInput
  >;
  deleteMany?: Maybe<MessageScalarWhereInput[] | MessageScalarWhereInput>;
  updateMany?: Maybe<
    | MessageUpdateManyWithWhereNestedInput[]
    | MessageUpdateManyWithWhereNestedInput
  >;
}

export interface MessageUpdateWithWhereUniqueWithoutCreatedByInput {
  where: MessageWhereUniqueInput;
  data: MessageUpdateWithoutCreatedByDataInput;
}

export interface MessageUpdateWithoutCreatedByDataInput {
  content?: Maybe<String>;
  status?: Maybe<MessageStatus>;
  starred?: Maybe<Boolean>;
  channel?: Maybe<ChannelUpdateOneRequiredWithoutMessagesInput>;
  seenBy?: Maybe<UserUpdateManyWithoutSeenMessagesInput>;
  receivedBy?: Maybe<UserUpdateManyInput>;
  tagged?: Maybe<UserUpdateManyWithoutTaggedMessagesInput>;
  reactions?: Maybe<ReactionUpdateManyWithoutMessageInput>;
}

export interface ChannelUpdateOneRequiredWithoutMessagesInput {
  create?: Maybe<ChannelCreateWithoutMessagesInput>;
  update?: Maybe<ChannelUpdateWithoutMessagesDataInput>;
  upsert?: Maybe<ChannelUpsertWithoutMessagesInput>;
  connect?: Maybe<ChannelWhereUniqueInput>;
}

export interface ChannelUpdateWithoutMessagesDataInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  archived?: Maybe<Boolean>;
  members?: Maybe<UserUpdateManyWithoutChannelsInput>;
  media?: Maybe<MediaUpdateManyWithoutChannelInput>;
  createdBy?: Maybe<UserUpdateOneRequiredWithoutCreatedChannelsInput>;
}

export interface MediaUpdateManyWithoutChannelInput {
  create?: Maybe<
    MediaCreateWithoutChannelInput[] | MediaCreateWithoutChannelInput
  >;
  delete?: Maybe<MediaWhereUniqueInput[] | MediaWhereUniqueInput>;
  connect?: Maybe<MediaWhereUniqueInput[] | MediaWhereUniqueInput>;
  set?: Maybe<MediaWhereUniqueInput[] | MediaWhereUniqueInput>;
  disconnect?: Maybe<MediaWhereUniqueInput[] | MediaWhereUniqueInput>;
  update?: Maybe<
    | MediaUpdateWithWhereUniqueWithoutChannelInput[]
    | MediaUpdateWithWhereUniqueWithoutChannelInput
  >;
  upsert?: Maybe<
    | MediaUpsertWithWhereUniqueWithoutChannelInput[]
    | MediaUpsertWithWhereUniqueWithoutChannelInput
  >;
  deleteMany?: Maybe<MediaScalarWhereInput[] | MediaScalarWhereInput>;
  updateMany?: Maybe<
    MediaUpdateManyWithWhereNestedInput[] | MediaUpdateManyWithWhereNestedInput
  >;
}

export interface MediaUpdateWithWhereUniqueWithoutChannelInput {
  where: MediaWhereUniqueInput;
  data: MediaUpdateWithoutChannelDataInput;
}

export interface MediaUpdateWithoutChannelDataInput {
  url?: Maybe<String>;
  status?: Maybe<MessageStatus>;
  starred?: Maybe<Boolean>;
  uploadedBy?: Maybe<UserUpdateOneRequiredWithoutMediaInput>;
  seenBy?: Maybe<UserUpdateManyWithoutSeenMediaInput>;
  receivedBy?: Maybe<UserUpdateManyWithoutReceivedMediaInput>;
}

export interface UserUpdateOneRequiredWithoutMediaInput {
  create?: Maybe<UserCreateWithoutMediaInput>;
  update?: Maybe<UserUpdateWithoutMediaDataInput>;
  upsert?: Maybe<UserUpsertWithoutMediaInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserUpdateWithoutMediaDataInput {
  name?: Maybe<String>;
  rollNumber?: Maybe<String>;
  email?: Maybe<String>;
  password?: Maybe<String>;
  mobile?: Maybe<String>;
  upi?: Maybe<String>;
  about?: Maybe<String>;
  profilePic?: Maybe<String>;
  coverPic?: Maybe<String>;
  role?: Maybe<AccessLevel>;
  department?: Maybe<DepartmentUpdateOneWithoutMembersInput>;
  channels?: Maybe<ChannelUpdateManyWithoutMembersInput>;
  messages?: Maybe<MessageUpdateManyWithoutCreatedByInput>;
  seenMessages?: Maybe<MessageUpdateManyWithoutSeenByInput>;
  receivedMessages?: Maybe<MessageUpdateManyInput>;
  seenMedia?: Maybe<MediaUpdateManyWithoutSeenByInput>;
  receivedMedia?: Maybe<MediaUpdateManyWithoutReceivedByInput>;
  createdChannels?: Maybe<ChannelUpdateManyWithoutCreatedByInput>;
  taggedMessages?: Maybe<MessageUpdateManyWithoutTaggedInput>;
  reactions?: Maybe<ReactionUpdateManyWithoutByInput>;
}

export interface ChannelUpdateManyWithoutMembersInput {
  create?: Maybe<
    ChannelCreateWithoutMembersInput[] | ChannelCreateWithoutMembersInput
  >;
  delete?: Maybe<ChannelWhereUniqueInput[] | ChannelWhereUniqueInput>;
  connect?: Maybe<ChannelWhereUniqueInput[] | ChannelWhereUniqueInput>;
  set?: Maybe<ChannelWhereUniqueInput[] | ChannelWhereUniqueInput>;
  disconnect?: Maybe<ChannelWhereUniqueInput[] | ChannelWhereUniqueInput>;
  update?: Maybe<
    | ChannelUpdateWithWhereUniqueWithoutMembersInput[]
    | ChannelUpdateWithWhereUniqueWithoutMembersInput
  >;
  upsert?: Maybe<
    | ChannelUpsertWithWhereUniqueWithoutMembersInput[]
    | ChannelUpsertWithWhereUniqueWithoutMembersInput
  >;
  deleteMany?: Maybe<ChannelScalarWhereInput[] | ChannelScalarWhereInput>;
  updateMany?: Maybe<
    | ChannelUpdateManyWithWhereNestedInput[]
    | ChannelUpdateManyWithWhereNestedInput
  >;
}

export interface ChannelUpdateWithWhereUniqueWithoutMembersInput {
  where: ChannelWhereUniqueInput;
  data: ChannelUpdateWithoutMembersDataInput;
}

export interface ChannelUpdateWithoutMembersDataInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  archived?: Maybe<Boolean>;
  messages?: Maybe<MessageUpdateManyWithoutChannelInput>;
  media?: Maybe<MediaUpdateManyWithoutChannelInput>;
  createdBy?: Maybe<UserUpdateOneRequiredWithoutCreatedChannelsInput>;
}

export interface MessageUpdateManyWithoutChannelInput {
  create?: Maybe<
    MessageCreateWithoutChannelInput[] | MessageCreateWithoutChannelInput
  >;
  delete?: Maybe<MessageWhereUniqueInput[] | MessageWhereUniqueInput>;
  connect?: Maybe<MessageWhereUniqueInput[] | MessageWhereUniqueInput>;
  set?: Maybe<MessageWhereUniqueInput[] | MessageWhereUniqueInput>;
  disconnect?: Maybe<MessageWhereUniqueInput[] | MessageWhereUniqueInput>;
  update?: Maybe<
    | MessageUpdateWithWhereUniqueWithoutChannelInput[]
    | MessageUpdateWithWhereUniqueWithoutChannelInput
  >;
  upsert?: Maybe<
    | MessageUpsertWithWhereUniqueWithoutChannelInput[]
    | MessageUpsertWithWhereUniqueWithoutChannelInput
  >;
  deleteMany?: Maybe<MessageScalarWhereInput[] | MessageScalarWhereInput>;
  updateMany?: Maybe<
    | MessageUpdateManyWithWhereNestedInput[]
    | MessageUpdateManyWithWhereNestedInput
  >;
}

export interface MessageUpdateWithWhereUniqueWithoutChannelInput {
  where: MessageWhereUniqueInput;
  data: MessageUpdateWithoutChannelDataInput;
}

export interface MessageUpdateWithoutChannelDataInput {
  content?: Maybe<String>;
  status?: Maybe<MessageStatus>;
  starred?: Maybe<Boolean>;
  createdBy?: Maybe<UserUpdateOneRequiredWithoutMessagesInput>;
  seenBy?: Maybe<UserUpdateManyWithoutSeenMessagesInput>;
  receivedBy?: Maybe<UserUpdateManyInput>;
  tagged?: Maybe<UserUpdateManyWithoutTaggedMessagesInput>;
  reactions?: Maybe<ReactionUpdateManyWithoutMessageInput>;
}

export interface UserUpdateOneRequiredWithoutMessagesInput {
  create?: Maybe<UserCreateWithoutMessagesInput>;
  update?: Maybe<UserUpdateWithoutMessagesDataInput>;
  upsert?: Maybe<UserUpsertWithoutMessagesInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserUpdateWithoutMessagesDataInput {
  name?: Maybe<String>;
  rollNumber?: Maybe<String>;
  email?: Maybe<String>;
  password?: Maybe<String>;
  mobile?: Maybe<String>;
  upi?: Maybe<String>;
  about?: Maybe<String>;
  profilePic?: Maybe<String>;
  coverPic?: Maybe<String>;
  role?: Maybe<AccessLevel>;
  department?: Maybe<DepartmentUpdateOneWithoutMembersInput>;
  channels?: Maybe<ChannelUpdateManyWithoutMembersInput>;
  seenMessages?: Maybe<MessageUpdateManyWithoutSeenByInput>;
  receivedMessages?: Maybe<MessageUpdateManyInput>;
  seenMedia?: Maybe<MediaUpdateManyWithoutSeenByInput>;
  receivedMedia?: Maybe<MediaUpdateManyWithoutReceivedByInput>;
  media?: Maybe<MediaUpdateManyWithoutUploadedByInput>;
  createdChannels?: Maybe<ChannelUpdateManyWithoutCreatedByInput>;
  taggedMessages?: Maybe<MessageUpdateManyWithoutTaggedInput>;
  reactions?: Maybe<ReactionUpdateManyWithoutByInput>;
}

export interface MessageUpdateManyWithoutSeenByInput {
  create?: Maybe<
    MessageCreateWithoutSeenByInput[] | MessageCreateWithoutSeenByInput
  >;
  delete?: Maybe<MessageWhereUniqueInput[] | MessageWhereUniqueInput>;
  connect?: Maybe<MessageWhereUniqueInput[] | MessageWhereUniqueInput>;
  set?: Maybe<MessageWhereUniqueInput[] | MessageWhereUniqueInput>;
  disconnect?: Maybe<MessageWhereUniqueInput[] | MessageWhereUniqueInput>;
  update?: Maybe<
    | MessageUpdateWithWhereUniqueWithoutSeenByInput[]
    | MessageUpdateWithWhereUniqueWithoutSeenByInput
  >;
  upsert?: Maybe<
    | MessageUpsertWithWhereUniqueWithoutSeenByInput[]
    | MessageUpsertWithWhereUniqueWithoutSeenByInput
  >;
  deleteMany?: Maybe<MessageScalarWhereInput[] | MessageScalarWhereInput>;
  updateMany?: Maybe<
    | MessageUpdateManyWithWhereNestedInput[]
    | MessageUpdateManyWithWhereNestedInput
  >;
}

export interface MessageUpdateWithWhereUniqueWithoutSeenByInput {
  where: MessageWhereUniqueInput;
  data: MessageUpdateWithoutSeenByDataInput;
}

export interface MessageUpdateWithoutSeenByDataInput {
  content?: Maybe<String>;
  status?: Maybe<MessageStatus>;
  starred?: Maybe<Boolean>;
  createdBy?: Maybe<UserUpdateOneRequiredWithoutMessagesInput>;
  channel?: Maybe<ChannelUpdateOneRequiredWithoutMessagesInput>;
  receivedBy?: Maybe<UserUpdateManyInput>;
  tagged?: Maybe<UserUpdateManyWithoutTaggedMessagesInput>;
  reactions?: Maybe<ReactionUpdateManyWithoutMessageInput>;
}

export interface UserUpdateManyInput {
  create?: Maybe<UserCreateInput[] | UserCreateInput>;
  update?: Maybe<
    | UserUpdateWithWhereUniqueNestedInput[]
    | UserUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | UserUpsertWithWhereUniqueNestedInput[]
    | UserUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  connect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  set?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  disconnect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  deleteMany?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
  updateMany?: Maybe<
    UserUpdateManyWithWhereNestedInput[] | UserUpdateManyWithWhereNestedInput
  >;
}

export interface UserUpdateWithWhereUniqueNestedInput {
  where: UserWhereUniqueInput;
  data: UserUpdateDataInput;
}

export interface UserUpdateDataInput {
  name?: Maybe<String>;
  rollNumber?: Maybe<String>;
  email?: Maybe<String>;
  password?: Maybe<String>;
  mobile?: Maybe<String>;
  upi?: Maybe<String>;
  about?: Maybe<String>;
  profilePic?: Maybe<String>;
  coverPic?: Maybe<String>;
  role?: Maybe<AccessLevel>;
  department?: Maybe<DepartmentUpdateOneWithoutMembersInput>;
  channels?: Maybe<ChannelUpdateManyWithoutMembersInput>;
  messages?: Maybe<MessageUpdateManyWithoutCreatedByInput>;
  seenMessages?: Maybe<MessageUpdateManyWithoutSeenByInput>;
  receivedMessages?: Maybe<MessageUpdateManyInput>;
  seenMedia?: Maybe<MediaUpdateManyWithoutSeenByInput>;
  receivedMedia?: Maybe<MediaUpdateManyWithoutReceivedByInput>;
  media?: Maybe<MediaUpdateManyWithoutUploadedByInput>;
  createdChannels?: Maybe<ChannelUpdateManyWithoutCreatedByInput>;
  taggedMessages?: Maybe<MessageUpdateManyWithoutTaggedInput>;
  reactions?: Maybe<ReactionUpdateManyWithoutByInput>;
}

export interface MessageUpdateManyInput {
  create?: Maybe<MessageCreateInput[] | MessageCreateInput>;
  update?: Maybe<
    | MessageUpdateWithWhereUniqueNestedInput[]
    | MessageUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | MessageUpsertWithWhereUniqueNestedInput[]
    | MessageUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<MessageWhereUniqueInput[] | MessageWhereUniqueInput>;
  connect?: Maybe<MessageWhereUniqueInput[] | MessageWhereUniqueInput>;
  set?: Maybe<MessageWhereUniqueInput[] | MessageWhereUniqueInput>;
  disconnect?: Maybe<MessageWhereUniqueInput[] | MessageWhereUniqueInput>;
  deleteMany?: Maybe<MessageScalarWhereInput[] | MessageScalarWhereInput>;
  updateMany?: Maybe<
    | MessageUpdateManyWithWhereNestedInput[]
    | MessageUpdateManyWithWhereNestedInput
  >;
}

export interface MessageUpdateWithWhereUniqueNestedInput {
  where: MessageWhereUniqueInput;
  data: MessageUpdateDataInput;
}

export interface MessageUpdateDataInput {
  content?: Maybe<String>;
  status?: Maybe<MessageStatus>;
  starred?: Maybe<Boolean>;
  createdBy?: Maybe<UserUpdateOneRequiredWithoutMessagesInput>;
  channel?: Maybe<ChannelUpdateOneRequiredWithoutMessagesInput>;
  seenBy?: Maybe<UserUpdateManyWithoutSeenMessagesInput>;
  receivedBy?: Maybe<UserUpdateManyInput>;
  tagged?: Maybe<UserUpdateManyWithoutTaggedMessagesInput>;
  reactions?: Maybe<ReactionUpdateManyWithoutMessageInput>;
}

export interface UserUpdateManyWithoutSeenMessagesInput {
  create?: Maybe<
    UserCreateWithoutSeenMessagesInput[] | UserCreateWithoutSeenMessagesInput
  >;
  delete?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  connect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  set?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  disconnect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  update?: Maybe<
    | UserUpdateWithWhereUniqueWithoutSeenMessagesInput[]
    | UserUpdateWithWhereUniqueWithoutSeenMessagesInput
  >;
  upsert?: Maybe<
    | UserUpsertWithWhereUniqueWithoutSeenMessagesInput[]
    | UserUpsertWithWhereUniqueWithoutSeenMessagesInput
  >;
  deleteMany?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
  updateMany?: Maybe<
    UserUpdateManyWithWhereNestedInput[] | UserUpdateManyWithWhereNestedInput
  >;
}

export interface UserUpdateWithWhereUniqueWithoutSeenMessagesInput {
  where: UserWhereUniqueInput;
  data: UserUpdateWithoutSeenMessagesDataInput;
}

export interface UserUpdateWithoutSeenMessagesDataInput {
  name?: Maybe<String>;
  rollNumber?: Maybe<String>;
  email?: Maybe<String>;
  password?: Maybe<String>;
  mobile?: Maybe<String>;
  upi?: Maybe<String>;
  about?: Maybe<String>;
  profilePic?: Maybe<String>;
  coverPic?: Maybe<String>;
  role?: Maybe<AccessLevel>;
  department?: Maybe<DepartmentUpdateOneWithoutMembersInput>;
  channels?: Maybe<ChannelUpdateManyWithoutMembersInput>;
  messages?: Maybe<MessageUpdateManyWithoutCreatedByInput>;
  receivedMessages?: Maybe<MessageUpdateManyInput>;
  seenMedia?: Maybe<MediaUpdateManyWithoutSeenByInput>;
  receivedMedia?: Maybe<MediaUpdateManyWithoutReceivedByInput>;
  media?: Maybe<MediaUpdateManyWithoutUploadedByInput>;
  createdChannels?: Maybe<ChannelUpdateManyWithoutCreatedByInput>;
  taggedMessages?: Maybe<MessageUpdateManyWithoutTaggedInput>;
  reactions?: Maybe<ReactionUpdateManyWithoutByInput>;
}

export interface MediaUpdateManyWithoutSeenByInput {
  create?: Maybe<
    MediaCreateWithoutSeenByInput[] | MediaCreateWithoutSeenByInput
  >;
  delete?: Maybe<MediaWhereUniqueInput[] | MediaWhereUniqueInput>;
  connect?: Maybe<MediaWhereUniqueInput[] | MediaWhereUniqueInput>;
  set?: Maybe<MediaWhereUniqueInput[] | MediaWhereUniqueInput>;
  disconnect?: Maybe<MediaWhereUniqueInput[] | MediaWhereUniqueInput>;
  update?: Maybe<
    | MediaUpdateWithWhereUniqueWithoutSeenByInput[]
    | MediaUpdateWithWhereUniqueWithoutSeenByInput
  >;
  upsert?: Maybe<
    | MediaUpsertWithWhereUniqueWithoutSeenByInput[]
    | MediaUpsertWithWhereUniqueWithoutSeenByInput
  >;
  deleteMany?: Maybe<MediaScalarWhereInput[] | MediaScalarWhereInput>;
  updateMany?: Maybe<
    MediaUpdateManyWithWhereNestedInput[] | MediaUpdateManyWithWhereNestedInput
  >;
}

export interface MediaUpdateWithWhereUniqueWithoutSeenByInput {
  where: MediaWhereUniqueInput;
  data: MediaUpdateWithoutSeenByDataInput;
}

export interface MediaUpdateWithoutSeenByDataInput {
  url?: Maybe<String>;
  status?: Maybe<MessageStatus>;
  starred?: Maybe<Boolean>;
  uploadedBy?: Maybe<UserUpdateOneRequiredWithoutMediaInput>;
  channel?: Maybe<ChannelUpdateOneRequiredWithoutMediaInput>;
  receivedBy?: Maybe<UserUpdateManyWithoutReceivedMediaInput>;
}

export interface ChannelUpdateOneRequiredWithoutMediaInput {
  create?: Maybe<ChannelCreateWithoutMediaInput>;
  update?: Maybe<ChannelUpdateWithoutMediaDataInput>;
  upsert?: Maybe<ChannelUpsertWithoutMediaInput>;
  connect?: Maybe<ChannelWhereUniqueInput>;
}

export interface ChannelUpdateWithoutMediaDataInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  archived?: Maybe<Boolean>;
  members?: Maybe<UserUpdateManyWithoutChannelsInput>;
  messages?: Maybe<MessageUpdateManyWithoutChannelInput>;
  createdBy?: Maybe<UserUpdateOneRequiredWithoutCreatedChannelsInput>;
}

export interface UserUpdateOneRequiredWithoutCreatedChannelsInput {
  create?: Maybe<UserCreateWithoutCreatedChannelsInput>;
  update?: Maybe<UserUpdateWithoutCreatedChannelsDataInput>;
  upsert?: Maybe<UserUpsertWithoutCreatedChannelsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserUpdateWithoutCreatedChannelsDataInput {
  name?: Maybe<String>;
  rollNumber?: Maybe<String>;
  email?: Maybe<String>;
  password?: Maybe<String>;
  mobile?: Maybe<String>;
  upi?: Maybe<String>;
  about?: Maybe<String>;
  profilePic?: Maybe<String>;
  coverPic?: Maybe<String>;
  role?: Maybe<AccessLevel>;
  department?: Maybe<DepartmentUpdateOneWithoutMembersInput>;
  channels?: Maybe<ChannelUpdateManyWithoutMembersInput>;
  messages?: Maybe<MessageUpdateManyWithoutCreatedByInput>;
  seenMessages?: Maybe<MessageUpdateManyWithoutSeenByInput>;
  receivedMessages?: Maybe<MessageUpdateManyInput>;
  seenMedia?: Maybe<MediaUpdateManyWithoutSeenByInput>;
  receivedMedia?: Maybe<MediaUpdateManyWithoutReceivedByInput>;
  media?: Maybe<MediaUpdateManyWithoutUploadedByInput>;
  taggedMessages?: Maybe<MessageUpdateManyWithoutTaggedInput>;
  reactions?: Maybe<ReactionUpdateManyWithoutByInput>;
}

export interface MediaUpdateManyWithoutReceivedByInput {
  create?: Maybe<
    MediaCreateWithoutReceivedByInput[] | MediaCreateWithoutReceivedByInput
  >;
  delete?: Maybe<MediaWhereUniqueInput[] | MediaWhereUniqueInput>;
  connect?: Maybe<MediaWhereUniqueInput[] | MediaWhereUniqueInput>;
  set?: Maybe<MediaWhereUniqueInput[] | MediaWhereUniqueInput>;
  disconnect?: Maybe<MediaWhereUniqueInput[] | MediaWhereUniqueInput>;
  update?: Maybe<
    | MediaUpdateWithWhereUniqueWithoutReceivedByInput[]
    | MediaUpdateWithWhereUniqueWithoutReceivedByInput
  >;
  upsert?: Maybe<
    | MediaUpsertWithWhereUniqueWithoutReceivedByInput[]
    | MediaUpsertWithWhereUniqueWithoutReceivedByInput
  >;
  deleteMany?: Maybe<MediaScalarWhereInput[] | MediaScalarWhereInput>;
  updateMany?: Maybe<
    MediaUpdateManyWithWhereNestedInput[] | MediaUpdateManyWithWhereNestedInput
  >;
}

export interface MediaUpdateWithWhereUniqueWithoutReceivedByInput {
  where: MediaWhereUniqueInput;
  data: MediaUpdateWithoutReceivedByDataInput;
}

export interface MediaUpdateWithoutReceivedByDataInput {
  url?: Maybe<String>;
  status?: Maybe<MessageStatus>;
  starred?: Maybe<Boolean>;
  uploadedBy?: Maybe<UserUpdateOneRequiredWithoutMediaInput>;
  channel?: Maybe<ChannelUpdateOneRequiredWithoutMediaInput>;
  seenBy?: Maybe<UserUpdateManyWithoutSeenMediaInput>;
}

export interface UserUpdateManyWithoutSeenMediaInput {
  create?: Maybe<
    UserCreateWithoutSeenMediaInput[] | UserCreateWithoutSeenMediaInput
  >;
  delete?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  connect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  set?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  disconnect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  update?: Maybe<
    | UserUpdateWithWhereUniqueWithoutSeenMediaInput[]
    | UserUpdateWithWhereUniqueWithoutSeenMediaInput
  >;
  upsert?: Maybe<
    | UserUpsertWithWhereUniqueWithoutSeenMediaInput[]
    | UserUpsertWithWhereUniqueWithoutSeenMediaInput
  >;
  deleteMany?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
  updateMany?: Maybe<
    UserUpdateManyWithWhereNestedInput[] | UserUpdateManyWithWhereNestedInput
  >;
}

export interface UserUpdateWithWhereUniqueWithoutSeenMediaInput {
  where: UserWhereUniqueInput;
  data: UserUpdateWithoutSeenMediaDataInput;
}

export interface UserUpdateWithoutSeenMediaDataInput {
  name?: Maybe<String>;
  rollNumber?: Maybe<String>;
  email?: Maybe<String>;
  password?: Maybe<String>;
  mobile?: Maybe<String>;
  upi?: Maybe<String>;
  about?: Maybe<String>;
  profilePic?: Maybe<String>;
  coverPic?: Maybe<String>;
  role?: Maybe<AccessLevel>;
  department?: Maybe<DepartmentUpdateOneWithoutMembersInput>;
  channels?: Maybe<ChannelUpdateManyWithoutMembersInput>;
  messages?: Maybe<MessageUpdateManyWithoutCreatedByInput>;
  seenMessages?: Maybe<MessageUpdateManyWithoutSeenByInput>;
  receivedMessages?: Maybe<MessageUpdateManyInput>;
  receivedMedia?: Maybe<MediaUpdateManyWithoutReceivedByInput>;
  media?: Maybe<MediaUpdateManyWithoutUploadedByInput>;
  createdChannels?: Maybe<ChannelUpdateManyWithoutCreatedByInput>;
  taggedMessages?: Maybe<MessageUpdateManyWithoutTaggedInput>;
  reactions?: Maybe<ReactionUpdateManyWithoutByInput>;
}

export interface MediaUpdateManyWithoutUploadedByInput {
  create?: Maybe<
    MediaCreateWithoutUploadedByInput[] | MediaCreateWithoutUploadedByInput
  >;
  delete?: Maybe<MediaWhereUniqueInput[] | MediaWhereUniqueInput>;
  connect?: Maybe<MediaWhereUniqueInput[] | MediaWhereUniqueInput>;
  set?: Maybe<MediaWhereUniqueInput[] | MediaWhereUniqueInput>;
  disconnect?: Maybe<MediaWhereUniqueInput[] | MediaWhereUniqueInput>;
  update?: Maybe<
    | MediaUpdateWithWhereUniqueWithoutUploadedByInput[]
    | MediaUpdateWithWhereUniqueWithoutUploadedByInput
  >;
  upsert?: Maybe<
    | MediaUpsertWithWhereUniqueWithoutUploadedByInput[]
    | MediaUpsertWithWhereUniqueWithoutUploadedByInput
  >;
  deleteMany?: Maybe<MediaScalarWhereInput[] | MediaScalarWhereInput>;
  updateMany?: Maybe<
    MediaUpdateManyWithWhereNestedInput[] | MediaUpdateManyWithWhereNestedInput
  >;
}

export interface MediaUpdateWithWhereUniqueWithoutUploadedByInput {
  where: MediaWhereUniqueInput;
  data: MediaUpdateWithoutUploadedByDataInput;
}

export interface MediaUpdateWithoutUploadedByDataInput {
  url?: Maybe<String>;
  status?: Maybe<MessageStatus>;
  starred?: Maybe<Boolean>;
  channel?: Maybe<ChannelUpdateOneRequiredWithoutMediaInput>;
  seenBy?: Maybe<UserUpdateManyWithoutSeenMediaInput>;
  receivedBy?: Maybe<UserUpdateManyWithoutReceivedMediaInput>;
}

export interface UserUpdateManyWithoutReceivedMediaInput {
  create?: Maybe<
    UserCreateWithoutReceivedMediaInput[] | UserCreateWithoutReceivedMediaInput
  >;
  delete?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  connect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  set?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  disconnect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  update?: Maybe<
    | UserUpdateWithWhereUniqueWithoutReceivedMediaInput[]
    | UserUpdateWithWhereUniqueWithoutReceivedMediaInput
  >;
  upsert?: Maybe<
    | UserUpsertWithWhereUniqueWithoutReceivedMediaInput[]
    | UserUpsertWithWhereUniqueWithoutReceivedMediaInput
  >;
  deleteMany?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
  updateMany?: Maybe<
    UserUpdateManyWithWhereNestedInput[] | UserUpdateManyWithWhereNestedInput
  >;
}

export interface UserUpdateWithWhereUniqueWithoutReceivedMediaInput {
  where: UserWhereUniqueInput;
  data: UserUpdateWithoutReceivedMediaDataInput;
}

export interface UserUpdateWithoutReceivedMediaDataInput {
  name?: Maybe<String>;
  rollNumber?: Maybe<String>;
  email?: Maybe<String>;
  password?: Maybe<String>;
  mobile?: Maybe<String>;
  upi?: Maybe<String>;
  about?: Maybe<String>;
  profilePic?: Maybe<String>;
  coverPic?: Maybe<String>;
  role?: Maybe<AccessLevel>;
  department?: Maybe<DepartmentUpdateOneWithoutMembersInput>;
  channels?: Maybe<ChannelUpdateManyWithoutMembersInput>;
  messages?: Maybe<MessageUpdateManyWithoutCreatedByInput>;
  seenMessages?: Maybe<MessageUpdateManyWithoutSeenByInput>;
  receivedMessages?: Maybe<MessageUpdateManyInput>;
  seenMedia?: Maybe<MediaUpdateManyWithoutSeenByInput>;
  media?: Maybe<MediaUpdateManyWithoutUploadedByInput>;
  createdChannels?: Maybe<ChannelUpdateManyWithoutCreatedByInput>;
  taggedMessages?: Maybe<MessageUpdateManyWithoutTaggedInput>;
  reactions?: Maybe<ReactionUpdateManyWithoutByInput>;
}

export interface ChannelUpdateManyWithoutCreatedByInput {
  create?: Maybe<
    ChannelCreateWithoutCreatedByInput[] | ChannelCreateWithoutCreatedByInput
  >;
  delete?: Maybe<ChannelWhereUniqueInput[] | ChannelWhereUniqueInput>;
  connect?: Maybe<ChannelWhereUniqueInput[] | ChannelWhereUniqueInput>;
  set?: Maybe<ChannelWhereUniqueInput[] | ChannelWhereUniqueInput>;
  disconnect?: Maybe<ChannelWhereUniqueInput[] | ChannelWhereUniqueInput>;
  update?: Maybe<
    | ChannelUpdateWithWhereUniqueWithoutCreatedByInput[]
    | ChannelUpdateWithWhereUniqueWithoutCreatedByInput
  >;
  upsert?: Maybe<
    | ChannelUpsertWithWhereUniqueWithoutCreatedByInput[]
    | ChannelUpsertWithWhereUniqueWithoutCreatedByInput
  >;
  deleteMany?: Maybe<ChannelScalarWhereInput[] | ChannelScalarWhereInput>;
  updateMany?: Maybe<
    | ChannelUpdateManyWithWhereNestedInput[]
    | ChannelUpdateManyWithWhereNestedInput
  >;
}

export interface ChannelUpdateWithWhereUniqueWithoutCreatedByInput {
  where: ChannelWhereUniqueInput;
  data: ChannelUpdateWithoutCreatedByDataInput;
}

export interface ChannelUpdateWithoutCreatedByDataInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  archived?: Maybe<Boolean>;
  members?: Maybe<UserUpdateManyWithoutChannelsInput>;
  messages?: Maybe<MessageUpdateManyWithoutChannelInput>;
  media?: Maybe<MediaUpdateManyWithoutChannelInput>;
}

export interface ChannelUpsertWithWhereUniqueWithoutCreatedByInput {
  where: ChannelWhereUniqueInput;
  update: ChannelUpdateWithoutCreatedByDataInput;
  create: ChannelCreateWithoutCreatedByInput;
}

export interface ChannelScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  archived?: Maybe<Boolean>;
  archived_not?: Maybe<Boolean>;
  AND?: Maybe<ChannelScalarWhereInput[] | ChannelScalarWhereInput>;
  OR?: Maybe<ChannelScalarWhereInput[] | ChannelScalarWhereInput>;
  NOT?: Maybe<ChannelScalarWhereInput[] | ChannelScalarWhereInput>;
}

export interface ChannelUpdateManyWithWhereNestedInput {
  where: ChannelScalarWhereInput;
  data: ChannelUpdateManyDataInput;
}

export interface ChannelUpdateManyDataInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  archived?: Maybe<Boolean>;
}

export interface MessageUpdateManyWithoutTaggedInput {
  create?: Maybe<
    MessageCreateWithoutTaggedInput[] | MessageCreateWithoutTaggedInput
  >;
  delete?: Maybe<MessageWhereUniqueInput[] | MessageWhereUniqueInput>;
  connect?: Maybe<MessageWhereUniqueInput[] | MessageWhereUniqueInput>;
  set?: Maybe<MessageWhereUniqueInput[] | MessageWhereUniqueInput>;
  disconnect?: Maybe<MessageWhereUniqueInput[] | MessageWhereUniqueInput>;
  update?: Maybe<
    | MessageUpdateWithWhereUniqueWithoutTaggedInput[]
    | MessageUpdateWithWhereUniqueWithoutTaggedInput
  >;
  upsert?: Maybe<
    | MessageUpsertWithWhereUniqueWithoutTaggedInput[]
    | MessageUpsertWithWhereUniqueWithoutTaggedInput
  >;
  deleteMany?: Maybe<MessageScalarWhereInput[] | MessageScalarWhereInput>;
  updateMany?: Maybe<
    | MessageUpdateManyWithWhereNestedInput[]
    | MessageUpdateManyWithWhereNestedInput
  >;
}

export interface MessageUpdateWithWhereUniqueWithoutTaggedInput {
  where: MessageWhereUniqueInput;
  data: MessageUpdateWithoutTaggedDataInput;
}

export interface MessageUpdateWithoutTaggedDataInput {
  content?: Maybe<String>;
  status?: Maybe<MessageStatus>;
  starred?: Maybe<Boolean>;
  createdBy?: Maybe<UserUpdateOneRequiredWithoutMessagesInput>;
  channel?: Maybe<ChannelUpdateOneRequiredWithoutMessagesInput>;
  seenBy?: Maybe<UserUpdateManyWithoutSeenMessagesInput>;
  receivedBy?: Maybe<UserUpdateManyInput>;
  reactions?: Maybe<ReactionUpdateManyWithoutMessageInput>;
}

export interface ReactionUpdateManyWithoutMessageInput {
  create?: Maybe<
    ReactionCreateWithoutMessageInput[] | ReactionCreateWithoutMessageInput
  >;
  delete?: Maybe<ReactionWhereUniqueInput[] | ReactionWhereUniqueInput>;
  connect?: Maybe<ReactionWhereUniqueInput[] | ReactionWhereUniqueInput>;
  set?: Maybe<ReactionWhereUniqueInput[] | ReactionWhereUniqueInput>;
  disconnect?: Maybe<ReactionWhereUniqueInput[] | ReactionWhereUniqueInput>;
  update?: Maybe<
    | ReactionUpdateWithWhereUniqueWithoutMessageInput[]
    | ReactionUpdateWithWhereUniqueWithoutMessageInput
  >;
  upsert?: Maybe<
    | ReactionUpsertWithWhereUniqueWithoutMessageInput[]
    | ReactionUpsertWithWhereUniqueWithoutMessageInput
  >;
  deleteMany?: Maybe<ReactionScalarWhereInput[] | ReactionScalarWhereInput>;
  updateMany?: Maybe<
    | ReactionUpdateManyWithWhereNestedInput[]
    | ReactionUpdateManyWithWhereNestedInput
  >;
}

export interface ReactionUpdateWithWhereUniqueWithoutMessageInput {
  where: ReactionWhereUniqueInput;
  data: ReactionUpdateWithoutMessageDataInput;
}

export interface ReactionUpdateWithoutMessageDataInput {
  type?: Maybe<ReactionType>;
  by?: Maybe<UserUpdateOneRequiredWithoutReactionsInput>;
}

export interface UserUpdateOneRequiredWithoutReactionsInput {
  create?: Maybe<UserCreateWithoutReactionsInput>;
  update?: Maybe<UserUpdateWithoutReactionsDataInput>;
  upsert?: Maybe<UserUpsertWithoutReactionsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserUpdateWithoutReactionsDataInput {
  name?: Maybe<String>;
  rollNumber?: Maybe<String>;
  email?: Maybe<String>;
  password?: Maybe<String>;
  mobile?: Maybe<String>;
  upi?: Maybe<String>;
  about?: Maybe<String>;
  profilePic?: Maybe<String>;
  coverPic?: Maybe<String>;
  role?: Maybe<AccessLevel>;
  department?: Maybe<DepartmentUpdateOneWithoutMembersInput>;
  channels?: Maybe<ChannelUpdateManyWithoutMembersInput>;
  messages?: Maybe<MessageUpdateManyWithoutCreatedByInput>;
  seenMessages?: Maybe<MessageUpdateManyWithoutSeenByInput>;
  receivedMessages?: Maybe<MessageUpdateManyInput>;
  seenMedia?: Maybe<MediaUpdateManyWithoutSeenByInput>;
  receivedMedia?: Maybe<MediaUpdateManyWithoutReceivedByInput>;
  media?: Maybe<MediaUpdateManyWithoutUploadedByInput>;
  createdChannels?: Maybe<ChannelUpdateManyWithoutCreatedByInput>;
  taggedMessages?: Maybe<MessageUpdateManyWithoutTaggedInput>;
}

export interface UserUpsertWithoutReactionsInput {
  update: UserUpdateWithoutReactionsDataInput;
  create: UserCreateWithoutReactionsInput;
}

export interface ReactionUpsertWithWhereUniqueWithoutMessageInput {
  where: ReactionWhereUniqueInput;
  update: ReactionUpdateWithoutMessageDataInput;
  create: ReactionCreateWithoutMessageInput;
}

export interface ReactionScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  type?: Maybe<ReactionType>;
  type_not?: Maybe<ReactionType>;
  type_in?: Maybe<ReactionType[] | ReactionType>;
  type_not_in?: Maybe<ReactionType[] | ReactionType>;
  AND?: Maybe<ReactionScalarWhereInput[] | ReactionScalarWhereInput>;
  OR?: Maybe<ReactionScalarWhereInput[] | ReactionScalarWhereInput>;
  NOT?: Maybe<ReactionScalarWhereInput[] | ReactionScalarWhereInput>;
}

export interface ReactionUpdateManyWithWhereNestedInput {
  where: ReactionScalarWhereInput;
  data: ReactionUpdateManyDataInput;
}

export interface ReactionUpdateManyDataInput {
  type?: Maybe<ReactionType>;
}

export interface MessageUpsertWithWhereUniqueWithoutTaggedInput {
  where: MessageWhereUniqueInput;
  update: MessageUpdateWithoutTaggedDataInput;
  create: MessageCreateWithoutTaggedInput;
}

export interface MessageScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  content?: Maybe<String>;
  content_not?: Maybe<String>;
  content_in?: Maybe<String[] | String>;
  content_not_in?: Maybe<String[] | String>;
  content_lt?: Maybe<String>;
  content_lte?: Maybe<String>;
  content_gt?: Maybe<String>;
  content_gte?: Maybe<String>;
  content_contains?: Maybe<String>;
  content_not_contains?: Maybe<String>;
  content_starts_with?: Maybe<String>;
  content_not_starts_with?: Maybe<String>;
  content_ends_with?: Maybe<String>;
  content_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  status?: Maybe<MessageStatus>;
  status_not?: Maybe<MessageStatus>;
  status_in?: Maybe<MessageStatus[] | MessageStatus>;
  status_not_in?: Maybe<MessageStatus[] | MessageStatus>;
  starred?: Maybe<Boolean>;
  starred_not?: Maybe<Boolean>;
  AND?: Maybe<MessageScalarWhereInput[] | MessageScalarWhereInput>;
  OR?: Maybe<MessageScalarWhereInput[] | MessageScalarWhereInput>;
  NOT?: Maybe<MessageScalarWhereInput[] | MessageScalarWhereInput>;
}

export interface MessageUpdateManyWithWhereNestedInput {
  where: MessageScalarWhereInput;
  data: MessageUpdateManyDataInput;
}

export interface MessageUpdateManyDataInput {
  content?: Maybe<String>;
  status?: Maybe<MessageStatus>;
  starred?: Maybe<Boolean>;
}

export interface ReactionUpdateManyWithoutByInput {
  create?: Maybe<ReactionCreateWithoutByInput[] | ReactionCreateWithoutByInput>;
  delete?: Maybe<ReactionWhereUniqueInput[] | ReactionWhereUniqueInput>;
  connect?: Maybe<ReactionWhereUniqueInput[] | ReactionWhereUniqueInput>;
  set?: Maybe<ReactionWhereUniqueInput[] | ReactionWhereUniqueInput>;
  disconnect?: Maybe<ReactionWhereUniqueInput[] | ReactionWhereUniqueInput>;
  update?: Maybe<
    | ReactionUpdateWithWhereUniqueWithoutByInput[]
    | ReactionUpdateWithWhereUniqueWithoutByInput
  >;
  upsert?: Maybe<
    | ReactionUpsertWithWhereUniqueWithoutByInput[]
    | ReactionUpsertWithWhereUniqueWithoutByInput
  >;
  deleteMany?: Maybe<ReactionScalarWhereInput[] | ReactionScalarWhereInput>;
  updateMany?: Maybe<
    | ReactionUpdateManyWithWhereNestedInput[]
    | ReactionUpdateManyWithWhereNestedInput
  >;
}

export interface ReactionUpdateWithWhereUniqueWithoutByInput {
  where: ReactionWhereUniqueInput;
  data: ReactionUpdateWithoutByDataInput;
}

export interface ReactionUpdateWithoutByDataInput {
  type?: Maybe<ReactionType>;
  message?: Maybe<MessageUpdateOneRequiredWithoutReactionsInput>;
}

export interface MessageUpdateOneRequiredWithoutReactionsInput {
  create?: Maybe<MessageCreateWithoutReactionsInput>;
  update?: Maybe<MessageUpdateWithoutReactionsDataInput>;
  upsert?: Maybe<MessageUpsertWithoutReactionsInput>;
  connect?: Maybe<MessageWhereUniqueInput>;
}

export interface MessageUpdateWithoutReactionsDataInput {
  content?: Maybe<String>;
  status?: Maybe<MessageStatus>;
  starred?: Maybe<Boolean>;
  createdBy?: Maybe<UserUpdateOneRequiredWithoutMessagesInput>;
  channel?: Maybe<ChannelUpdateOneRequiredWithoutMessagesInput>;
  seenBy?: Maybe<UserUpdateManyWithoutSeenMessagesInput>;
  receivedBy?: Maybe<UserUpdateManyInput>;
  tagged?: Maybe<UserUpdateManyWithoutTaggedMessagesInput>;
}

export interface UserUpdateManyWithoutTaggedMessagesInput {
  create?: Maybe<
    | UserCreateWithoutTaggedMessagesInput[]
    | UserCreateWithoutTaggedMessagesInput
  >;
  delete?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  connect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  set?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  disconnect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  update?: Maybe<
    | UserUpdateWithWhereUniqueWithoutTaggedMessagesInput[]
    | UserUpdateWithWhereUniqueWithoutTaggedMessagesInput
  >;
  upsert?: Maybe<
    | UserUpsertWithWhereUniqueWithoutTaggedMessagesInput[]
    | UserUpsertWithWhereUniqueWithoutTaggedMessagesInput
  >;
  deleteMany?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
  updateMany?: Maybe<
    UserUpdateManyWithWhereNestedInput[] | UserUpdateManyWithWhereNestedInput
  >;
}

export interface UserUpdateWithWhereUniqueWithoutTaggedMessagesInput {
  where: UserWhereUniqueInput;
  data: UserUpdateWithoutTaggedMessagesDataInput;
}

export interface UserUpdateWithoutTaggedMessagesDataInput {
  name?: Maybe<String>;
  rollNumber?: Maybe<String>;
  email?: Maybe<String>;
  password?: Maybe<String>;
  mobile?: Maybe<String>;
  upi?: Maybe<String>;
  about?: Maybe<String>;
  profilePic?: Maybe<String>;
  coverPic?: Maybe<String>;
  role?: Maybe<AccessLevel>;
  department?: Maybe<DepartmentUpdateOneWithoutMembersInput>;
  channels?: Maybe<ChannelUpdateManyWithoutMembersInput>;
  messages?: Maybe<MessageUpdateManyWithoutCreatedByInput>;
  seenMessages?: Maybe<MessageUpdateManyWithoutSeenByInput>;
  receivedMessages?: Maybe<MessageUpdateManyInput>;
  seenMedia?: Maybe<MediaUpdateManyWithoutSeenByInput>;
  receivedMedia?: Maybe<MediaUpdateManyWithoutReceivedByInput>;
  media?: Maybe<MediaUpdateManyWithoutUploadedByInput>;
  createdChannels?: Maybe<ChannelUpdateManyWithoutCreatedByInput>;
  reactions?: Maybe<ReactionUpdateManyWithoutByInput>;
}

export interface UserUpsertWithWhereUniqueWithoutTaggedMessagesInput {
  where: UserWhereUniqueInput;
  update: UserUpdateWithoutTaggedMessagesDataInput;
  create: UserCreateWithoutTaggedMessagesInput;
}

export interface UserScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  rollNumber?: Maybe<String>;
  rollNumber_not?: Maybe<String>;
  rollNumber_in?: Maybe<String[] | String>;
  rollNumber_not_in?: Maybe<String[] | String>;
  rollNumber_lt?: Maybe<String>;
  rollNumber_lte?: Maybe<String>;
  rollNumber_gt?: Maybe<String>;
  rollNumber_gte?: Maybe<String>;
  rollNumber_contains?: Maybe<String>;
  rollNumber_not_contains?: Maybe<String>;
  rollNumber_starts_with?: Maybe<String>;
  rollNumber_not_starts_with?: Maybe<String>;
  rollNumber_ends_with?: Maybe<String>;
  rollNumber_not_ends_with?: Maybe<String>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  password?: Maybe<String>;
  password_not?: Maybe<String>;
  password_in?: Maybe<String[] | String>;
  password_not_in?: Maybe<String[] | String>;
  password_lt?: Maybe<String>;
  password_lte?: Maybe<String>;
  password_gt?: Maybe<String>;
  password_gte?: Maybe<String>;
  password_contains?: Maybe<String>;
  password_not_contains?: Maybe<String>;
  password_starts_with?: Maybe<String>;
  password_not_starts_with?: Maybe<String>;
  password_ends_with?: Maybe<String>;
  password_not_ends_with?: Maybe<String>;
  mobile?: Maybe<String>;
  mobile_not?: Maybe<String>;
  mobile_in?: Maybe<String[] | String>;
  mobile_not_in?: Maybe<String[] | String>;
  mobile_lt?: Maybe<String>;
  mobile_lte?: Maybe<String>;
  mobile_gt?: Maybe<String>;
  mobile_gte?: Maybe<String>;
  mobile_contains?: Maybe<String>;
  mobile_not_contains?: Maybe<String>;
  mobile_starts_with?: Maybe<String>;
  mobile_not_starts_with?: Maybe<String>;
  mobile_ends_with?: Maybe<String>;
  mobile_not_ends_with?: Maybe<String>;
  upi?: Maybe<String>;
  upi_not?: Maybe<String>;
  upi_in?: Maybe<String[] | String>;
  upi_not_in?: Maybe<String[] | String>;
  upi_lt?: Maybe<String>;
  upi_lte?: Maybe<String>;
  upi_gt?: Maybe<String>;
  upi_gte?: Maybe<String>;
  upi_contains?: Maybe<String>;
  upi_not_contains?: Maybe<String>;
  upi_starts_with?: Maybe<String>;
  upi_not_starts_with?: Maybe<String>;
  upi_ends_with?: Maybe<String>;
  upi_not_ends_with?: Maybe<String>;
  about?: Maybe<String>;
  about_not?: Maybe<String>;
  about_in?: Maybe<String[] | String>;
  about_not_in?: Maybe<String[] | String>;
  about_lt?: Maybe<String>;
  about_lte?: Maybe<String>;
  about_gt?: Maybe<String>;
  about_gte?: Maybe<String>;
  about_contains?: Maybe<String>;
  about_not_contains?: Maybe<String>;
  about_starts_with?: Maybe<String>;
  about_not_starts_with?: Maybe<String>;
  about_ends_with?: Maybe<String>;
  about_not_ends_with?: Maybe<String>;
  profilePic?: Maybe<String>;
  profilePic_not?: Maybe<String>;
  profilePic_in?: Maybe<String[] | String>;
  profilePic_not_in?: Maybe<String[] | String>;
  profilePic_lt?: Maybe<String>;
  profilePic_lte?: Maybe<String>;
  profilePic_gt?: Maybe<String>;
  profilePic_gte?: Maybe<String>;
  profilePic_contains?: Maybe<String>;
  profilePic_not_contains?: Maybe<String>;
  profilePic_starts_with?: Maybe<String>;
  profilePic_not_starts_with?: Maybe<String>;
  profilePic_ends_with?: Maybe<String>;
  profilePic_not_ends_with?: Maybe<String>;
  coverPic?: Maybe<String>;
  coverPic_not?: Maybe<String>;
  coverPic_in?: Maybe<String[] | String>;
  coverPic_not_in?: Maybe<String[] | String>;
  coverPic_lt?: Maybe<String>;
  coverPic_lte?: Maybe<String>;
  coverPic_gt?: Maybe<String>;
  coverPic_gte?: Maybe<String>;
  coverPic_contains?: Maybe<String>;
  coverPic_not_contains?: Maybe<String>;
  coverPic_starts_with?: Maybe<String>;
  coverPic_not_starts_with?: Maybe<String>;
  coverPic_ends_with?: Maybe<String>;
  coverPic_not_ends_with?: Maybe<String>;
  role?: Maybe<AccessLevel>;
  role_not?: Maybe<AccessLevel>;
  role_in?: Maybe<AccessLevel[] | AccessLevel>;
  role_not_in?: Maybe<AccessLevel[] | AccessLevel>;
  AND?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
  OR?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
  NOT?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
}

export interface UserUpdateManyWithWhereNestedInput {
  where: UserScalarWhereInput;
  data: UserUpdateManyDataInput;
}

export interface UserUpdateManyDataInput {
  name?: Maybe<String>;
  rollNumber?: Maybe<String>;
  email?: Maybe<String>;
  password?: Maybe<String>;
  mobile?: Maybe<String>;
  upi?: Maybe<String>;
  about?: Maybe<String>;
  profilePic?: Maybe<String>;
  coverPic?: Maybe<String>;
  role?: Maybe<AccessLevel>;
}

export interface MessageUpsertWithoutReactionsInput {
  update: MessageUpdateWithoutReactionsDataInput;
  create: MessageCreateWithoutReactionsInput;
}

export interface ReactionUpsertWithWhereUniqueWithoutByInput {
  where: ReactionWhereUniqueInput;
  update: ReactionUpdateWithoutByDataInput;
  create: ReactionCreateWithoutByInput;
}

export interface UserUpsertWithWhereUniqueWithoutReceivedMediaInput {
  where: UserWhereUniqueInput;
  update: UserUpdateWithoutReceivedMediaDataInput;
  create: UserCreateWithoutReceivedMediaInput;
}

export interface MediaUpsertWithWhereUniqueWithoutUploadedByInput {
  where: MediaWhereUniqueInput;
  update: MediaUpdateWithoutUploadedByDataInput;
  create: MediaCreateWithoutUploadedByInput;
}

export interface MediaScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  url?: Maybe<String>;
  url_not?: Maybe<String>;
  url_in?: Maybe<String[] | String>;
  url_not_in?: Maybe<String[] | String>;
  url_lt?: Maybe<String>;
  url_lte?: Maybe<String>;
  url_gt?: Maybe<String>;
  url_gte?: Maybe<String>;
  url_contains?: Maybe<String>;
  url_not_contains?: Maybe<String>;
  url_starts_with?: Maybe<String>;
  url_not_starts_with?: Maybe<String>;
  url_ends_with?: Maybe<String>;
  url_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  status?: Maybe<MessageStatus>;
  status_not?: Maybe<MessageStatus>;
  status_in?: Maybe<MessageStatus[] | MessageStatus>;
  status_not_in?: Maybe<MessageStatus[] | MessageStatus>;
  starred?: Maybe<Boolean>;
  starred_not?: Maybe<Boolean>;
  AND?: Maybe<MediaScalarWhereInput[] | MediaScalarWhereInput>;
  OR?: Maybe<MediaScalarWhereInput[] | MediaScalarWhereInput>;
  NOT?: Maybe<MediaScalarWhereInput[] | MediaScalarWhereInput>;
}

export interface MediaUpdateManyWithWhereNestedInput {
  where: MediaScalarWhereInput;
  data: MediaUpdateManyDataInput;
}

export interface MediaUpdateManyDataInput {
  url?: Maybe<String>;
  status?: Maybe<MessageStatus>;
  starred?: Maybe<Boolean>;
}

export interface UserUpsertWithWhereUniqueWithoutSeenMediaInput {
  where: UserWhereUniqueInput;
  update: UserUpdateWithoutSeenMediaDataInput;
  create: UserCreateWithoutSeenMediaInput;
}

export interface MediaUpsertWithWhereUniqueWithoutReceivedByInput {
  where: MediaWhereUniqueInput;
  update: MediaUpdateWithoutReceivedByDataInput;
  create: MediaCreateWithoutReceivedByInput;
}

export interface UserUpsertWithoutCreatedChannelsInput {
  update: UserUpdateWithoutCreatedChannelsDataInput;
  create: UserCreateWithoutCreatedChannelsInput;
}

export interface ChannelUpsertWithoutMediaInput {
  update: ChannelUpdateWithoutMediaDataInput;
  create: ChannelCreateWithoutMediaInput;
}

export interface MediaUpsertWithWhereUniqueWithoutSeenByInput {
  where: MediaWhereUniqueInput;
  update: MediaUpdateWithoutSeenByDataInput;
  create: MediaCreateWithoutSeenByInput;
}

export interface UserUpsertWithWhereUniqueWithoutSeenMessagesInput {
  where: UserWhereUniqueInput;
  update: UserUpdateWithoutSeenMessagesDataInput;
  create: UserCreateWithoutSeenMessagesInput;
}

export interface MessageUpsertWithWhereUniqueNestedInput {
  where: MessageWhereUniqueInput;
  update: MessageUpdateDataInput;
  create: MessageCreateInput;
}

export interface UserUpsertWithWhereUniqueNestedInput {
  where: UserWhereUniqueInput;
  update: UserUpdateDataInput;
  create: UserCreateInput;
}

export interface MessageUpsertWithWhereUniqueWithoutSeenByInput {
  where: MessageWhereUniqueInput;
  update: MessageUpdateWithoutSeenByDataInput;
  create: MessageCreateWithoutSeenByInput;
}

export interface UserUpsertWithoutMessagesInput {
  update: UserUpdateWithoutMessagesDataInput;
  create: UserCreateWithoutMessagesInput;
}

export interface MessageUpsertWithWhereUniqueWithoutChannelInput {
  where: MessageWhereUniqueInput;
  update: MessageUpdateWithoutChannelDataInput;
  create: MessageCreateWithoutChannelInput;
}

export interface ChannelUpsertWithWhereUniqueWithoutMembersInput {
  where: ChannelWhereUniqueInput;
  update: ChannelUpdateWithoutMembersDataInput;
  create: ChannelCreateWithoutMembersInput;
}

export interface UserUpsertWithoutMediaInput {
  update: UserUpdateWithoutMediaDataInput;
  create: UserCreateWithoutMediaInput;
}

export interface MediaUpsertWithWhereUniqueWithoutChannelInput {
  where: MediaWhereUniqueInput;
  update: MediaUpdateWithoutChannelDataInput;
  create: MediaCreateWithoutChannelInput;
}

export interface ChannelUpsertWithoutMessagesInput {
  update: ChannelUpdateWithoutMessagesDataInput;
  create: ChannelCreateWithoutMessagesInput;
}

export interface MessageUpsertWithWhereUniqueWithoutCreatedByInput {
  where: MessageWhereUniqueInput;
  update: MessageUpdateWithoutCreatedByDataInput;
  create: MessageCreateWithoutCreatedByInput;
}

export interface UserUpsertWithWhereUniqueWithoutChannelsInput {
  where: UserWhereUniqueInput;
  update: UserUpdateWithoutChannelsDataInput;
  create: UserCreateWithoutChannelsInput;
}

export interface ChannelUpdateManyMutationInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  archived?: Maybe<Boolean>;
}

export interface DepartmentCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  subDepartments?: Maybe<DepartmentCreatesubDepartmentsInput>;
  members?: Maybe<UserCreateManyWithoutDepartmentInput>;
}

export interface UserCreateManyWithoutDepartmentInput {
  create?: Maybe<
    UserCreateWithoutDepartmentInput[] | UserCreateWithoutDepartmentInput
  >;
  connect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
}

export interface UserCreateWithoutDepartmentInput {
  id?: Maybe<ID_Input>;
  name: String;
  rollNumber: String;
  email: String;
  password: String;
  mobile: String;
  upi: String;
  about?: Maybe<String>;
  profilePic: String;
  coverPic: String;
  role?: Maybe<AccessLevel>;
  channels?: Maybe<ChannelCreateManyWithoutMembersInput>;
  messages?: Maybe<MessageCreateManyWithoutCreatedByInput>;
  seenMessages?: Maybe<MessageCreateManyWithoutSeenByInput>;
  receivedMessages?: Maybe<MessageCreateManyInput>;
  seenMedia?: Maybe<MediaCreateManyWithoutSeenByInput>;
  receivedMedia?: Maybe<MediaCreateManyWithoutReceivedByInput>;
  media?: Maybe<MediaCreateManyWithoutUploadedByInput>;
  createdChannels?: Maybe<ChannelCreateManyWithoutCreatedByInput>;
  taggedMessages?: Maybe<MessageCreateManyWithoutTaggedInput>;
  reactions?: Maybe<ReactionCreateManyWithoutByInput>;
}

export interface DepartmentUpdateInput {
  name?: Maybe<String>;
  subDepartments?: Maybe<DepartmentUpdatesubDepartmentsInput>;
  members?: Maybe<UserUpdateManyWithoutDepartmentInput>;
}

export interface UserUpdateManyWithoutDepartmentInput {
  create?: Maybe<
    UserCreateWithoutDepartmentInput[] | UserCreateWithoutDepartmentInput
  >;
  delete?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  connect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  set?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  disconnect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  update?: Maybe<
    | UserUpdateWithWhereUniqueWithoutDepartmentInput[]
    | UserUpdateWithWhereUniqueWithoutDepartmentInput
  >;
  upsert?: Maybe<
    | UserUpsertWithWhereUniqueWithoutDepartmentInput[]
    | UserUpsertWithWhereUniqueWithoutDepartmentInput
  >;
  deleteMany?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
  updateMany?: Maybe<
    UserUpdateManyWithWhereNestedInput[] | UserUpdateManyWithWhereNestedInput
  >;
}

export interface UserUpdateWithWhereUniqueWithoutDepartmentInput {
  where: UserWhereUniqueInput;
  data: UserUpdateWithoutDepartmentDataInput;
}

export interface UserUpdateWithoutDepartmentDataInput {
  name?: Maybe<String>;
  rollNumber?: Maybe<String>;
  email?: Maybe<String>;
  password?: Maybe<String>;
  mobile?: Maybe<String>;
  upi?: Maybe<String>;
  about?: Maybe<String>;
  profilePic?: Maybe<String>;
  coverPic?: Maybe<String>;
  role?: Maybe<AccessLevel>;
  channels?: Maybe<ChannelUpdateManyWithoutMembersInput>;
  messages?: Maybe<MessageUpdateManyWithoutCreatedByInput>;
  seenMessages?: Maybe<MessageUpdateManyWithoutSeenByInput>;
  receivedMessages?: Maybe<MessageUpdateManyInput>;
  seenMedia?: Maybe<MediaUpdateManyWithoutSeenByInput>;
  receivedMedia?: Maybe<MediaUpdateManyWithoutReceivedByInput>;
  media?: Maybe<MediaUpdateManyWithoutUploadedByInput>;
  createdChannels?: Maybe<ChannelUpdateManyWithoutCreatedByInput>;
  taggedMessages?: Maybe<MessageUpdateManyWithoutTaggedInput>;
  reactions?: Maybe<ReactionUpdateManyWithoutByInput>;
}

export interface UserUpsertWithWhereUniqueWithoutDepartmentInput {
  where: UserWhereUniqueInput;
  update: UserUpdateWithoutDepartmentDataInput;
  create: UserCreateWithoutDepartmentInput;
}

export interface DepartmentUpdateManyMutationInput {
  name?: Maybe<String>;
  subDepartments?: Maybe<DepartmentUpdatesubDepartmentsInput>;
}

export interface MediaCreateInput {
  id?: Maybe<ID_Input>;
  url: String;
  status?: Maybe<MessageStatus>;
  starred?: Maybe<Boolean>;
  uploadedBy: UserCreateOneWithoutMediaInput;
  channel: ChannelCreateOneWithoutMediaInput;
  seenBy?: Maybe<UserCreateManyWithoutSeenMediaInput>;
  receivedBy?: Maybe<UserCreateManyWithoutReceivedMediaInput>;
}

export interface MediaUpdateInput {
  url?: Maybe<String>;
  status?: Maybe<MessageStatus>;
  starred?: Maybe<Boolean>;
  uploadedBy?: Maybe<UserUpdateOneRequiredWithoutMediaInput>;
  channel?: Maybe<ChannelUpdateOneRequiredWithoutMediaInput>;
  seenBy?: Maybe<UserUpdateManyWithoutSeenMediaInput>;
  receivedBy?: Maybe<UserUpdateManyWithoutReceivedMediaInput>;
}

export interface MediaUpdateManyMutationInput {
  url?: Maybe<String>;
  status?: Maybe<MessageStatus>;
  starred?: Maybe<Boolean>;
}

export interface MessageUpdateInput {
  content?: Maybe<String>;
  status?: Maybe<MessageStatus>;
  starred?: Maybe<Boolean>;
  createdBy?: Maybe<UserUpdateOneRequiredWithoutMessagesInput>;
  channel?: Maybe<ChannelUpdateOneRequiredWithoutMessagesInput>;
  seenBy?: Maybe<UserUpdateManyWithoutSeenMessagesInput>;
  receivedBy?: Maybe<UserUpdateManyInput>;
  tagged?: Maybe<UserUpdateManyWithoutTaggedMessagesInput>;
  reactions?: Maybe<ReactionUpdateManyWithoutMessageInput>;
}

export interface MessageUpdateManyMutationInput {
  content?: Maybe<String>;
  status?: Maybe<MessageStatus>;
  starred?: Maybe<Boolean>;
}

export interface ReactionCreateInput {
  id?: Maybe<ID_Input>;
  type: ReactionType;
  by: UserCreateOneWithoutReactionsInput;
  message: MessageCreateOneWithoutReactionsInput;
}

export interface ReactionUpdateInput {
  type?: Maybe<ReactionType>;
  by?: Maybe<UserUpdateOneRequiredWithoutReactionsInput>;
  message?: Maybe<MessageUpdateOneRequiredWithoutReactionsInput>;
}

export interface ReactionUpdateManyMutationInput {
  type?: Maybe<ReactionType>;
}

export interface UserUpdateInput {
  name?: Maybe<String>;
  rollNumber?: Maybe<String>;
  email?: Maybe<String>;
  password?: Maybe<String>;
  mobile?: Maybe<String>;
  upi?: Maybe<String>;
  about?: Maybe<String>;
  profilePic?: Maybe<String>;
  coverPic?: Maybe<String>;
  role?: Maybe<AccessLevel>;
  department?: Maybe<DepartmentUpdateOneWithoutMembersInput>;
  channels?: Maybe<ChannelUpdateManyWithoutMembersInput>;
  messages?: Maybe<MessageUpdateManyWithoutCreatedByInput>;
  seenMessages?: Maybe<MessageUpdateManyWithoutSeenByInput>;
  receivedMessages?: Maybe<MessageUpdateManyInput>;
  seenMedia?: Maybe<MediaUpdateManyWithoutSeenByInput>;
  receivedMedia?: Maybe<MediaUpdateManyWithoutReceivedByInput>;
  media?: Maybe<MediaUpdateManyWithoutUploadedByInput>;
  createdChannels?: Maybe<ChannelUpdateManyWithoutCreatedByInput>;
  taggedMessages?: Maybe<MessageUpdateManyWithoutTaggedInput>;
  reactions?: Maybe<ReactionUpdateManyWithoutByInput>;
}

export interface UserUpdateManyMutationInput {
  name?: Maybe<String>;
  rollNumber?: Maybe<String>;
  email?: Maybe<String>;
  password?: Maybe<String>;
  mobile?: Maybe<String>;
  upi?: Maybe<String>;
  about?: Maybe<String>;
  profilePic?: Maybe<String>;
  coverPic?: Maybe<String>;
  role?: Maybe<AccessLevel>;
}

export interface ChannelSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ChannelWhereInput>;
  AND?: Maybe<ChannelSubscriptionWhereInput[] | ChannelSubscriptionWhereInput>;
  OR?: Maybe<ChannelSubscriptionWhereInput[] | ChannelSubscriptionWhereInput>;
  NOT?: Maybe<ChannelSubscriptionWhereInput[] | ChannelSubscriptionWhereInput>;
}

export interface DepartmentSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<DepartmentWhereInput>;
  AND?: Maybe<
    DepartmentSubscriptionWhereInput[] | DepartmentSubscriptionWhereInput
  >;
  OR?: Maybe<
    DepartmentSubscriptionWhereInput[] | DepartmentSubscriptionWhereInput
  >;
  NOT?: Maybe<
    DepartmentSubscriptionWhereInput[] | DepartmentSubscriptionWhereInput
  >;
}

export interface MediaSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<MediaWhereInput>;
  AND?: Maybe<MediaSubscriptionWhereInput[] | MediaSubscriptionWhereInput>;
  OR?: Maybe<MediaSubscriptionWhereInput[] | MediaSubscriptionWhereInput>;
  NOT?: Maybe<MediaSubscriptionWhereInput[] | MediaSubscriptionWhereInput>;
}

export interface MessageSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<MessageWhereInput>;
  AND?: Maybe<MessageSubscriptionWhereInput[] | MessageSubscriptionWhereInput>;
  OR?: Maybe<MessageSubscriptionWhereInput[] | MessageSubscriptionWhereInput>;
  NOT?: Maybe<MessageSubscriptionWhereInput[] | MessageSubscriptionWhereInput>;
}

export interface ReactionSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ReactionWhereInput>;
  AND?: Maybe<
    ReactionSubscriptionWhereInput[] | ReactionSubscriptionWhereInput
  >;
  OR?: Maybe<ReactionSubscriptionWhereInput[] | ReactionSubscriptionWhereInput>;
  NOT?: Maybe<
    ReactionSubscriptionWhereInput[] | ReactionSubscriptionWhereInput
  >;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<UserWhereInput>;
  AND?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  OR?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  NOT?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
}

export interface NodeNode {
  id: ID_Output;
}

export interface Channel {
  id: ID_Output;
  name: String;
  createdAt: DateTimeOutput;
  description: String;
  archived: Boolean;
}

export interface ChannelPromise extends Promise<Channel>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  description: () => Promise<String>;
  archived: () => Promise<Boolean>;
  members: <T = FragmentableArray<User>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  messages: <T = FragmentableArray<Message>>(args?: {
    where?: MessageWhereInput;
    orderBy?: MessageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  media: <T = FragmentableArray<Media>>(args?: {
    where?: MediaWhereInput;
    orderBy?: MediaOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdBy: <T = UserPromise>() => T;
}

export interface ChannelSubscription
  extends Promise<AsyncIterator<Channel>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  description: () => Promise<AsyncIterator<String>>;
  archived: () => Promise<AsyncIterator<Boolean>>;
  members: <T = Promise<AsyncIterator<UserSubscription>>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  messages: <T = Promise<AsyncIterator<MessageSubscription>>>(args?: {
    where?: MessageWhereInput;
    orderBy?: MessageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  media: <T = Promise<AsyncIterator<MediaSubscription>>>(args?: {
    where?: MediaWhereInput;
    orderBy?: MediaOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdBy: <T = UserSubscription>() => T;
}

export interface ChannelNullablePromise
  extends Promise<Channel | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  description: () => Promise<String>;
  archived: () => Promise<Boolean>;
  members: <T = FragmentableArray<User>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  messages: <T = FragmentableArray<Message>>(args?: {
    where?: MessageWhereInput;
    orderBy?: MessageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  media: <T = FragmentableArray<Media>>(args?: {
    where?: MediaWhereInput;
    orderBy?: MediaOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdBy: <T = UserPromise>() => T;
}

export interface User {
  id: ID_Output;
  name: String;
  rollNumber: String;
  email: String;
  password: String;
  mobile: String;
  upi: String;
  about: String;
  profilePic: String;
  coverPic: String;
  role: AccessLevel;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  rollNumber: () => Promise<String>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  mobile: () => Promise<String>;
  upi: () => Promise<String>;
  about: () => Promise<String>;
  profilePic: () => Promise<String>;
  coverPic: () => Promise<String>;
  role: () => Promise<AccessLevel>;
  department: <T = DepartmentPromise>() => T;
  channels: <T = FragmentableArray<Channel>>(args?: {
    where?: ChannelWhereInput;
    orderBy?: ChannelOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  messages: <T = FragmentableArray<Message>>(args?: {
    where?: MessageWhereInput;
    orderBy?: MessageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  seenMessages: <T = FragmentableArray<Message>>(args?: {
    where?: MessageWhereInput;
    orderBy?: MessageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  receivedMessages: <T = FragmentableArray<Message>>(args?: {
    where?: MessageWhereInput;
    orderBy?: MessageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  seenMedia: <T = FragmentableArray<Media>>(args?: {
    where?: MediaWhereInput;
    orderBy?: MediaOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  receivedMedia: <T = FragmentableArray<Media>>(args?: {
    where?: MediaWhereInput;
    orderBy?: MediaOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  media: <T = FragmentableArray<Media>>(args?: {
    where?: MediaWhereInput;
    orderBy?: MediaOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdChannels: <T = FragmentableArray<Channel>>(args?: {
    where?: ChannelWhereInput;
    orderBy?: ChannelOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  taggedMessages: <T = FragmentableArray<Message>>(args?: {
    where?: MessageWhereInput;
    orderBy?: MessageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  reactions: <T = FragmentableArray<Reaction>>(args?: {
    where?: ReactionWhereInput;
    orderBy?: ReactionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  rollNumber: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  mobile: () => Promise<AsyncIterator<String>>;
  upi: () => Promise<AsyncIterator<String>>;
  about: () => Promise<AsyncIterator<String>>;
  profilePic: () => Promise<AsyncIterator<String>>;
  coverPic: () => Promise<AsyncIterator<String>>;
  role: () => Promise<AsyncIterator<AccessLevel>>;
  department: <T = DepartmentSubscription>() => T;
  channels: <T = Promise<AsyncIterator<ChannelSubscription>>>(args?: {
    where?: ChannelWhereInput;
    orderBy?: ChannelOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  messages: <T = Promise<AsyncIterator<MessageSubscription>>>(args?: {
    where?: MessageWhereInput;
    orderBy?: MessageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  seenMessages: <T = Promise<AsyncIterator<MessageSubscription>>>(args?: {
    where?: MessageWhereInput;
    orderBy?: MessageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  receivedMessages: <T = Promise<AsyncIterator<MessageSubscription>>>(args?: {
    where?: MessageWhereInput;
    orderBy?: MessageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  seenMedia: <T = Promise<AsyncIterator<MediaSubscription>>>(args?: {
    where?: MediaWhereInput;
    orderBy?: MediaOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  receivedMedia: <T = Promise<AsyncIterator<MediaSubscription>>>(args?: {
    where?: MediaWhereInput;
    orderBy?: MediaOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  media: <T = Promise<AsyncIterator<MediaSubscription>>>(args?: {
    where?: MediaWhereInput;
    orderBy?: MediaOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdChannels: <T = Promise<AsyncIterator<ChannelSubscription>>>(args?: {
    where?: ChannelWhereInput;
    orderBy?: ChannelOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  taggedMessages: <T = Promise<AsyncIterator<MessageSubscription>>>(args?: {
    where?: MessageWhereInput;
    orderBy?: MessageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  reactions: <T = Promise<AsyncIterator<ReactionSubscription>>>(args?: {
    where?: ReactionWhereInput;
    orderBy?: ReactionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface UserNullablePromise
  extends Promise<User | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  rollNumber: () => Promise<String>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  mobile: () => Promise<String>;
  upi: () => Promise<String>;
  about: () => Promise<String>;
  profilePic: () => Promise<String>;
  coverPic: () => Promise<String>;
  role: () => Promise<AccessLevel>;
  department: <T = DepartmentPromise>() => T;
  channels: <T = FragmentableArray<Channel>>(args?: {
    where?: ChannelWhereInput;
    orderBy?: ChannelOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  messages: <T = FragmentableArray<Message>>(args?: {
    where?: MessageWhereInput;
    orderBy?: MessageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  seenMessages: <T = FragmentableArray<Message>>(args?: {
    where?: MessageWhereInput;
    orderBy?: MessageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  receivedMessages: <T = FragmentableArray<Message>>(args?: {
    where?: MessageWhereInput;
    orderBy?: MessageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  seenMedia: <T = FragmentableArray<Media>>(args?: {
    where?: MediaWhereInput;
    orderBy?: MediaOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  receivedMedia: <T = FragmentableArray<Media>>(args?: {
    where?: MediaWhereInput;
    orderBy?: MediaOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  media: <T = FragmentableArray<Media>>(args?: {
    where?: MediaWhereInput;
    orderBy?: MediaOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdChannels: <T = FragmentableArray<Channel>>(args?: {
    where?: ChannelWhereInput;
    orderBy?: ChannelOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  taggedMessages: <T = FragmentableArray<Message>>(args?: {
    where?: MessageWhereInput;
    orderBy?: MessageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  reactions: <T = FragmentableArray<Reaction>>(args?: {
    where?: ReactionWhereInput;
    orderBy?: ReactionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface Department {
  id: ID_Output;
  name: String;
  subDepartments: String[];
}

export interface DepartmentPromise extends Promise<Department>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  subDepartments: () => Promise<String[]>;
  members: <T = FragmentableArray<User>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface DepartmentSubscription
  extends Promise<AsyncIterator<Department>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  subDepartments: () => Promise<AsyncIterator<String[]>>;
  members: <T = Promise<AsyncIterator<UserSubscription>>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface DepartmentNullablePromise
  extends Promise<Department | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  subDepartments: () => Promise<String[]>;
  members: <T = FragmentableArray<User>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface Message {
  id: ID_Output;
  content: String;
  createdAt: DateTimeOutput;
  status: MessageStatus;
  starred: Boolean;
}

export interface MessagePromise extends Promise<Message>, Fragmentable {
  id: () => Promise<ID_Output>;
  content: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  status: () => Promise<MessageStatus>;
  starred: () => Promise<Boolean>;
  createdBy: <T = UserPromise>() => T;
  channel: <T = ChannelPromise>() => T;
  seenBy: <T = FragmentableArray<User>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  receivedBy: <T = FragmentableArray<User>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  tagged: <T = FragmentableArray<User>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  reactions: <T = FragmentableArray<Reaction>>(args?: {
    where?: ReactionWhereInput;
    orderBy?: ReactionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface MessageSubscription
  extends Promise<AsyncIterator<Message>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  content: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  status: () => Promise<AsyncIterator<MessageStatus>>;
  starred: () => Promise<AsyncIterator<Boolean>>;
  createdBy: <T = UserSubscription>() => T;
  channel: <T = ChannelSubscription>() => T;
  seenBy: <T = Promise<AsyncIterator<UserSubscription>>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  receivedBy: <T = Promise<AsyncIterator<UserSubscription>>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  tagged: <T = Promise<AsyncIterator<UserSubscription>>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  reactions: <T = Promise<AsyncIterator<ReactionSubscription>>>(args?: {
    where?: ReactionWhereInput;
    orderBy?: ReactionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface MessageNullablePromise
  extends Promise<Message | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  content: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  status: () => Promise<MessageStatus>;
  starred: () => Promise<Boolean>;
  createdBy: <T = UserPromise>() => T;
  channel: <T = ChannelPromise>() => T;
  seenBy: <T = FragmentableArray<User>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  receivedBy: <T = FragmentableArray<User>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  tagged: <T = FragmentableArray<User>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  reactions: <T = FragmentableArray<Reaction>>(args?: {
    where?: ReactionWhereInput;
    orderBy?: ReactionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface Reaction {
  id: ID_Output;
  type: ReactionType;
}

export interface ReactionPromise extends Promise<Reaction>, Fragmentable {
  id: () => Promise<ID_Output>;
  type: () => Promise<ReactionType>;
  by: <T = UserPromise>() => T;
  message: <T = MessagePromise>() => T;
}

export interface ReactionSubscription
  extends Promise<AsyncIterator<Reaction>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  type: () => Promise<AsyncIterator<ReactionType>>;
  by: <T = UserSubscription>() => T;
  message: <T = MessageSubscription>() => T;
}

export interface ReactionNullablePromise
  extends Promise<Reaction | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  type: () => Promise<ReactionType>;
  by: <T = UserPromise>() => T;
  message: <T = MessagePromise>() => T;
}

export interface Media {
  id: ID_Output;
  url: String;
  createdAt: DateTimeOutput;
  status: MessageStatus;
  starred: Boolean;
}

export interface MediaPromise extends Promise<Media>, Fragmentable {
  id: () => Promise<ID_Output>;
  url: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  status: () => Promise<MessageStatus>;
  starred: () => Promise<Boolean>;
  uploadedBy: <T = UserPromise>() => T;
  channel: <T = ChannelPromise>() => T;
  seenBy: <T = FragmentableArray<User>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  receivedBy: <T = FragmentableArray<User>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface MediaSubscription
  extends Promise<AsyncIterator<Media>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  url: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  status: () => Promise<AsyncIterator<MessageStatus>>;
  starred: () => Promise<AsyncIterator<Boolean>>;
  uploadedBy: <T = UserSubscription>() => T;
  channel: <T = ChannelSubscription>() => T;
  seenBy: <T = Promise<AsyncIterator<UserSubscription>>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  receivedBy: <T = Promise<AsyncIterator<UserSubscription>>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface MediaNullablePromise
  extends Promise<Media | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  url: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  status: () => Promise<MessageStatus>;
  starred: () => Promise<Boolean>;
  uploadedBy: <T = UserPromise>() => T;
  channel: <T = ChannelPromise>() => T;
  seenBy: <T = FragmentableArray<User>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  receivedBy: <T = FragmentableArray<User>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface ChannelConnection {
  pageInfo: PageInfo;
  edges: ChannelEdge[];
}

export interface ChannelConnectionPromise
  extends Promise<ChannelConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ChannelEdge>>() => T;
  aggregate: <T = AggregateChannelPromise>() => T;
}

export interface ChannelConnectionSubscription
  extends Promise<AsyncIterator<ChannelConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ChannelEdgeSubscription>>>() => T;
  aggregate: <T = AggregateChannelSubscription>() => T;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface ChannelEdge {
  node: Channel;
  cursor: String;
}

export interface ChannelEdgePromise extends Promise<ChannelEdge>, Fragmentable {
  node: <T = ChannelPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ChannelEdgeSubscription
  extends Promise<AsyncIterator<ChannelEdge>>,
    Fragmentable {
  node: <T = ChannelSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateChannel {
  count: Int;
}

export interface AggregateChannelPromise
  extends Promise<AggregateChannel>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateChannelSubscription
  extends Promise<AsyncIterator<AggregateChannel>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface DepartmentConnection {
  pageInfo: PageInfo;
  edges: DepartmentEdge[];
}

export interface DepartmentConnectionPromise
  extends Promise<DepartmentConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<DepartmentEdge>>() => T;
  aggregate: <T = AggregateDepartmentPromise>() => T;
}

export interface DepartmentConnectionSubscription
  extends Promise<AsyncIterator<DepartmentConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<DepartmentEdgeSubscription>>>() => T;
  aggregate: <T = AggregateDepartmentSubscription>() => T;
}

export interface DepartmentEdge {
  node: Department;
  cursor: String;
}

export interface DepartmentEdgePromise
  extends Promise<DepartmentEdge>,
    Fragmentable {
  node: <T = DepartmentPromise>() => T;
  cursor: () => Promise<String>;
}

export interface DepartmentEdgeSubscription
  extends Promise<AsyncIterator<DepartmentEdge>>,
    Fragmentable {
  node: <T = DepartmentSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateDepartment {
  count: Int;
}

export interface AggregateDepartmentPromise
  extends Promise<AggregateDepartment>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateDepartmentSubscription
  extends Promise<AsyncIterator<AggregateDepartment>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface MediaConnection {
  pageInfo: PageInfo;
  edges: MediaEdge[];
}

export interface MediaConnectionPromise
  extends Promise<MediaConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<MediaEdge>>() => T;
  aggregate: <T = AggregateMediaPromise>() => T;
}

export interface MediaConnectionSubscription
  extends Promise<AsyncIterator<MediaConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<MediaEdgeSubscription>>>() => T;
  aggregate: <T = AggregateMediaSubscription>() => T;
}

export interface MediaEdge {
  node: Media;
  cursor: String;
}

export interface MediaEdgePromise extends Promise<MediaEdge>, Fragmentable {
  node: <T = MediaPromise>() => T;
  cursor: () => Promise<String>;
}

export interface MediaEdgeSubscription
  extends Promise<AsyncIterator<MediaEdge>>,
    Fragmentable {
  node: <T = MediaSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateMedia {
  count: Int;
}

export interface AggregateMediaPromise
  extends Promise<AggregateMedia>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateMediaSubscription
  extends Promise<AsyncIterator<AggregateMedia>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface MessageConnection {
  pageInfo: PageInfo;
  edges: MessageEdge[];
}

export interface MessageConnectionPromise
  extends Promise<MessageConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<MessageEdge>>() => T;
  aggregate: <T = AggregateMessagePromise>() => T;
}

export interface MessageConnectionSubscription
  extends Promise<AsyncIterator<MessageConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<MessageEdgeSubscription>>>() => T;
  aggregate: <T = AggregateMessageSubscription>() => T;
}

export interface MessageEdge {
  node: Message;
  cursor: String;
}

export interface MessageEdgePromise extends Promise<MessageEdge>, Fragmentable {
  node: <T = MessagePromise>() => T;
  cursor: () => Promise<String>;
}

export interface MessageEdgeSubscription
  extends Promise<AsyncIterator<MessageEdge>>,
    Fragmentable {
  node: <T = MessageSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateMessage {
  count: Int;
}

export interface AggregateMessagePromise
  extends Promise<AggregateMessage>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateMessageSubscription
  extends Promise<AsyncIterator<AggregateMessage>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ReactionConnection {
  pageInfo: PageInfo;
  edges: ReactionEdge[];
}

export interface ReactionConnectionPromise
  extends Promise<ReactionConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ReactionEdge>>() => T;
  aggregate: <T = AggregateReactionPromise>() => T;
}

export interface ReactionConnectionSubscription
  extends Promise<AsyncIterator<ReactionConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ReactionEdgeSubscription>>>() => T;
  aggregate: <T = AggregateReactionSubscription>() => T;
}

export interface ReactionEdge {
  node: Reaction;
  cursor: String;
}

export interface ReactionEdgePromise
  extends Promise<ReactionEdge>,
    Fragmentable {
  node: <T = ReactionPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ReactionEdgeSubscription
  extends Promise<AsyncIterator<ReactionEdge>>,
    Fragmentable {
  node: <T = ReactionSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateReaction {
  count: Int;
}

export interface AggregateReactionPromise
  extends Promise<AggregateReaction>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateReactionSubscription
  extends Promise<AsyncIterator<AggregateReaction>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UserConnection {
  pageInfo: PageInfo;
  edges: UserEdge[];
}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface UserEdge {
  node: User;
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface ChannelSubscriptionPayload {
  mutation: MutationType;
  node: Channel;
  updatedFields: String[];
  previousValues: ChannelPreviousValues;
}

export interface ChannelSubscriptionPayloadPromise
  extends Promise<ChannelSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ChannelPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ChannelPreviousValuesPromise>() => T;
}

export interface ChannelSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ChannelSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ChannelSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ChannelPreviousValuesSubscription>() => T;
}

export interface ChannelPreviousValues {
  id: ID_Output;
  name: String;
  createdAt: DateTimeOutput;
  description: String;
  archived: Boolean;
}

export interface ChannelPreviousValuesPromise
  extends Promise<ChannelPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  description: () => Promise<String>;
  archived: () => Promise<Boolean>;
}

export interface ChannelPreviousValuesSubscription
  extends Promise<AsyncIterator<ChannelPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  description: () => Promise<AsyncIterator<String>>;
  archived: () => Promise<AsyncIterator<Boolean>>;
}

export interface DepartmentSubscriptionPayload {
  mutation: MutationType;
  node: Department;
  updatedFields: String[];
  previousValues: DepartmentPreviousValues;
}

export interface DepartmentSubscriptionPayloadPromise
  extends Promise<DepartmentSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = DepartmentPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = DepartmentPreviousValuesPromise>() => T;
}

export interface DepartmentSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<DepartmentSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = DepartmentSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = DepartmentPreviousValuesSubscription>() => T;
}

export interface DepartmentPreviousValues {
  id: ID_Output;
  name: String;
  subDepartments: String[];
}

export interface DepartmentPreviousValuesPromise
  extends Promise<DepartmentPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  subDepartments: () => Promise<String[]>;
}

export interface DepartmentPreviousValuesSubscription
  extends Promise<AsyncIterator<DepartmentPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  subDepartments: () => Promise<AsyncIterator<String[]>>;
}

export interface MediaSubscriptionPayload {
  mutation: MutationType;
  node: Media;
  updatedFields: String[];
  previousValues: MediaPreviousValues;
}

export interface MediaSubscriptionPayloadPromise
  extends Promise<MediaSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = MediaPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = MediaPreviousValuesPromise>() => T;
}

export interface MediaSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<MediaSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = MediaSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = MediaPreviousValuesSubscription>() => T;
}

export interface MediaPreviousValues {
  id: ID_Output;
  url: String;
  createdAt: DateTimeOutput;
  status: MessageStatus;
  starred: Boolean;
}

export interface MediaPreviousValuesPromise
  extends Promise<MediaPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  url: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  status: () => Promise<MessageStatus>;
  starred: () => Promise<Boolean>;
}

export interface MediaPreviousValuesSubscription
  extends Promise<AsyncIterator<MediaPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  url: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  status: () => Promise<AsyncIterator<MessageStatus>>;
  starred: () => Promise<AsyncIterator<Boolean>>;
}

export interface MessageSubscriptionPayload {
  mutation: MutationType;
  node: Message;
  updatedFields: String[];
  previousValues: MessagePreviousValues;
}

export interface MessageSubscriptionPayloadPromise
  extends Promise<MessageSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = MessagePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = MessagePreviousValuesPromise>() => T;
}

export interface MessageSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<MessageSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = MessageSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = MessagePreviousValuesSubscription>() => T;
}

export interface MessagePreviousValues {
  id: ID_Output;
  content: String;
  createdAt: DateTimeOutput;
  status: MessageStatus;
  starred: Boolean;
}

export interface MessagePreviousValuesPromise
  extends Promise<MessagePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  content: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  status: () => Promise<MessageStatus>;
  starred: () => Promise<Boolean>;
}

export interface MessagePreviousValuesSubscription
  extends Promise<AsyncIterator<MessagePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  content: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  status: () => Promise<AsyncIterator<MessageStatus>>;
  starred: () => Promise<AsyncIterator<Boolean>>;
}

export interface ReactionSubscriptionPayload {
  mutation: MutationType;
  node: Reaction;
  updatedFields: String[];
  previousValues: ReactionPreviousValues;
}

export interface ReactionSubscriptionPayloadPromise
  extends Promise<ReactionSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ReactionPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ReactionPreviousValuesPromise>() => T;
}

export interface ReactionSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ReactionSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ReactionSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ReactionPreviousValuesSubscription>() => T;
}

export interface ReactionPreviousValues {
  id: ID_Output;
  type: ReactionType;
}

export interface ReactionPreviousValuesPromise
  extends Promise<ReactionPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  type: () => Promise<ReactionType>;
}

export interface ReactionPreviousValuesSubscription
  extends Promise<AsyncIterator<ReactionPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  type: () => Promise<AsyncIterator<ReactionType>>;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  node: User;
  updatedFields: String[];
  previousValues: UserPreviousValues;
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface UserPreviousValues {
  id: ID_Output;
  name: String;
  rollNumber: String;
  email: String;
  password: String;
  mobile: String;
  upi: String;
  about: String;
  profilePic: String;
  coverPic: String;
  role: AccessLevel;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  rollNumber: () => Promise<String>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  mobile: () => Promise<String>;
  upi: () => Promise<String>;
  about: () => Promise<String>;
  profilePic: () => Promise<String>;
  coverPic: () => Promise<String>;
  role: () => Promise<AccessLevel>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  rollNumber: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  mobile: () => Promise<AsyncIterator<String>>;
  upi: () => Promise<AsyncIterator<String>>;
  about: () => Promise<AsyncIterator<String>>;
  profilePic: () => Promise<AsyncIterator<String>>;
  coverPic: () => Promise<AsyncIterator<String>>;
  role: () => Promise<AsyncIterator<AccessLevel>>;
}

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.
*/
export type Int = number;

export type Long = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "AccessLevel",
    embedded: false
  },
  {
    name: "MessageStatus",
    embedded: false
  },
  {
    name: "ReactionType",
    embedded: false
  },
  {
    name: "MediaType",
    embedded: false
  },
  {
    name: "User",
    embedded: false
  },
  {
    name: "Department",
    embedded: false
  },
  {
    name: "Channel",
    embedded: false
  },
  {
    name: "Message",
    embedded: false
  },
  {
    name: "Media",
    embedded: false
  },
  {
    name: "Reaction",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const Prisma = makePrismaClientClass<ClientConstructor<Prisma>>({
  typeDefs,
  models,
  endpoint: `${process.env["PRISMA_ENDPOINT"]}`,
  secret: `${process.env["PRISMA_SERVICE_SECRET"]}`
});
export const prisma = new Prisma();
