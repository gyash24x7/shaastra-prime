// Code generated by Prisma (prisma@1.34.10). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update
// it. For more information, please read the docs:
// https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
	BaseClientOptions,
	makePrismaClientClass,
	Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
	U[keyof U];

export type Maybe<T> = T | undefined | null;

export interface Exists {
	channel: ( where?: ChannelWhereInput ) => Promise<boolean>;
	department: ( where?: DepartmentWhereInput ) => Promise<boolean>;
	message: ( where?: MessageWhereInput ) => Promise<boolean>;
	user: ( where?: UserWhereInput ) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
	$fragment<T>( fragment: string | DocumentNode ): Promise<T>;
}

export interface Prisma {
	$exists: Exists;
	$graphql: <T = any>(
		query: string,
		variables?: { [key: string]: any }
	) => Promise<T>;

	/**
	 * Queries
	 */

	channel: ( where: ChannelWhereUniqueInput ) => ChannelNullablePromise;
	channels: ( args?: {
		where?: ChannelWhereInput;
		orderBy?: ChannelOrderByInput;
		skip?: Int;
		after?: String;
		before?: String;
		first?: Int;
		last?: Int;
	} ) => FragmentableArray<Channel>;
	channelsConnection: ( args?: {
		where?: ChannelWhereInput;
		orderBy?: ChannelOrderByInput;
		skip?: Int;
		after?: String;
		before?: String;
		first?: Int;
		last?: Int;
	} ) => ChannelConnectionPromise;
	department: ( where: DepartmentWhereUniqueInput ) => DepartmentNullablePromise;
	departments: ( args?: {
		where?: DepartmentWhereInput;
		orderBy?: DepartmentOrderByInput;
		skip?: Int;
		after?: String;
		before?: String;
		first?: Int;
		last?: Int;
	} ) => FragmentableArray<Department>;
	departmentsConnection: ( args?: {
		where?: DepartmentWhereInput;
		orderBy?: DepartmentOrderByInput;
		skip?: Int;
		after?: String;
		before?: String;
		first?: Int;
		last?: Int;
	} ) => DepartmentConnectionPromise;
	message: ( where: MessageWhereUniqueInput ) => MessageNullablePromise;
	messages: ( args?: {
		where?: MessageWhereInput;
		orderBy?: MessageOrderByInput;
		skip?: Int;
		after?: String;
		before?: String;
		first?: Int;
		last?: Int;
	} ) => FragmentableArray<Message>;
	messagesConnection: ( args?: {
		where?: MessageWhereInput;
		orderBy?: MessageOrderByInput;
		skip?: Int;
		after?: String;
		before?: String;
		first?: Int;
		last?: Int;
	} ) => MessageConnectionPromise;
	user: ( where: UserWhereUniqueInput ) => UserNullablePromise;
	users: ( args?: {
		where?: UserWhereInput;
		orderBy?: UserOrderByInput;
		skip?: Int;
		after?: String;
		before?: String;
		first?: Int;
		last?: Int;
	} ) => FragmentableArray<User>;
	usersConnection: ( args?: {
		where?: UserWhereInput;
		orderBy?: UserOrderByInput;
		skip?: Int;
		after?: String;
		before?: String;
		first?: Int;
		last?: Int;
	} ) => UserConnectionPromise;
	node: ( args: { id: ID_Output } ) => Node;

	/**
	 * Mutations
	 */

	createChannel: ( data: ChannelCreateInput ) => ChannelPromise;
	updateChannel: ( args: {
		data: ChannelUpdateInput;
		where: ChannelWhereUniqueInput;
	} ) => ChannelPromise;
	updateManyChannels: ( args: {
		data: ChannelUpdateManyMutationInput;
		where?: ChannelWhereInput;
	} ) => BatchPayloadPromise;
	upsertChannel: ( args: {
		where: ChannelWhereUniqueInput;
		create: ChannelCreateInput;
		update: ChannelUpdateInput;
	} ) => ChannelPromise;
	deleteChannel: ( where: ChannelWhereUniqueInput ) => ChannelPromise;
	deleteManyChannels: ( where?: ChannelWhereInput ) => BatchPayloadPromise;
	createDepartment: ( data: DepartmentCreateInput ) => DepartmentPromise;
	updateDepartment: ( args: {
		data: DepartmentUpdateInput;
		where: DepartmentWhereUniqueInput;
	} ) => DepartmentPromise;
	updateManyDepartments: ( args: {
		data: DepartmentUpdateManyMutationInput;
		where?: DepartmentWhereInput;
	} ) => BatchPayloadPromise;
	upsertDepartment: ( args: {
		where: DepartmentWhereUniqueInput;
		create: DepartmentCreateInput;
		update: DepartmentUpdateInput;
	} ) => DepartmentPromise;
	deleteDepartment: ( where: DepartmentWhereUniqueInput ) => DepartmentPromise;
	deleteManyDepartments: ( where?: DepartmentWhereInput ) => BatchPayloadPromise;
	createMessage: ( data: MessageCreateInput ) => MessagePromise;
	updateMessage: ( args: {
		data: MessageUpdateInput;
		where: MessageWhereUniqueInput;
	} ) => MessagePromise;
	updateManyMessages: ( args: {
		data: MessageUpdateManyMutationInput;
		where?: MessageWhereInput;
	} ) => BatchPayloadPromise;
	upsertMessage: ( args: {
		where: MessageWhereUniqueInput;
		create: MessageCreateInput;
		update: MessageUpdateInput;
	} ) => MessagePromise;
	deleteMessage: ( where: MessageWhereUniqueInput ) => MessagePromise;
	deleteManyMessages: ( where?: MessageWhereInput ) => BatchPayloadPromise;
	createUser: ( data: UserCreateInput ) => UserPromise;
	updateUser: ( args: {
		data: UserUpdateInput;
		where: UserWhereUniqueInput;
	} ) => UserPromise;
	updateManyUsers: ( args: {
		data: UserUpdateManyMutationInput;
		where?: UserWhereInput;
	} ) => BatchPayloadPromise;
	upsertUser: ( args: {
		where: UserWhereUniqueInput;
		create: UserCreateInput;
		update: UserUpdateInput;
	} ) => UserPromise;
	deleteUser: ( where: UserWhereUniqueInput ) => UserPromise;
	deleteManyUsers: ( where?: UserWhereInput ) => BatchPayloadPromise;

	/**
	 * Subscriptions
	 */

	$subscribe: Subscription;
}

export interface Subscription {
	channel: (
		where?: ChannelSubscriptionWhereInput
	) => ChannelSubscriptionPayloadSubscription;
	department: (
		where?: DepartmentSubscriptionWhereInput
	) => DepartmentSubscriptionPayloadSubscription;
	message: (
		where?: MessageSubscriptionWhereInput
	) => MessageSubscriptionPayloadSubscription;
	user: (
		where?: UserSubscriptionWhereInput
	) => UserSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
	new( options?: BaseClientOptions ): T;
}

/**
 * Types
 */

export type AccessLevel = "COORD" | "CORE" | "COCAS" | "COCAD" | "HEAD";

export type UserOrderByInput =
	| "id_ASC"
	| "id_DESC"
	| "name_ASC"
	| "name_DESC"
	| "rollNumber_ASC"
	| "rollNumber_DESC"
	| "email_ASC"
	| "email_DESC"
	| "mobile_ASC"
	| "mobile_DESC"
	| "upi_ASC"
	| "upi_DESC"
	| "profilePic_ASC"
	| "profilePic_DESC"
	| "coverPic_ASC"
	| "coverPic_DESC"
	| "role_ASC"
	| "role_DESC";

export type ChannelOrderByInput =
	| "id_ASC"
	| "id_DESC"
	| "name_ASC"
	| "name_DESC"
	| "createdAt_ASC"
	| "createdAt_DESC";

export type MessageOrderByInput =
	| "id_ASC"
	| "id_DESC"
	| "content_ASC"
	| "content_DESC"
	| "createdAt_ASC"
	| "createdAt_DESC";

export type DepartmentOrderByInput =
	| "id_ASC"
	| "id_DESC"
	| "name_ASC"
	| "name_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type ChannelWhereUniqueInput = AtLeastOne<{
	id: Maybe<ID_Input>;
}>;

export interface UserWhereInput {
	id?: Maybe<ID_Input>;
	id_not?: Maybe<ID_Input>;
	id_in?: Maybe<ID_Input[] | ID_Input>;
	id_not_in?: Maybe<ID_Input[] | ID_Input>;
	id_lt?: Maybe<ID_Input>;
	id_lte?: Maybe<ID_Input>;
	id_gt?: Maybe<ID_Input>;
	id_gte?: Maybe<ID_Input>;
	id_contains?: Maybe<ID_Input>;
	id_not_contains?: Maybe<ID_Input>;
	id_starts_with?: Maybe<ID_Input>;
	id_not_starts_with?: Maybe<ID_Input>;
	id_ends_with?: Maybe<ID_Input>;
	id_not_ends_with?: Maybe<ID_Input>;
	name?: Maybe<String>;
	name_not?: Maybe<String>;
	name_in?: Maybe<String[] | String>;
	name_not_in?: Maybe<String[] | String>;
	name_lt?: Maybe<String>;
	name_lte?: Maybe<String>;
	name_gt?: Maybe<String>;
	name_gte?: Maybe<String>;
	name_contains?: Maybe<String>;
	name_not_contains?: Maybe<String>;
	name_starts_with?: Maybe<String>;
	name_not_starts_with?: Maybe<String>;
	name_ends_with?: Maybe<String>;
	name_not_ends_with?: Maybe<String>;
	rollNumber?: Maybe<String>;
	rollNumber_not?: Maybe<String>;
	rollNumber_in?: Maybe<String[] | String>;
	rollNumber_not_in?: Maybe<String[] | String>;
	rollNumber_lt?: Maybe<String>;
	rollNumber_lte?: Maybe<String>;
	rollNumber_gt?: Maybe<String>;
	rollNumber_gte?: Maybe<String>;
	rollNumber_contains?: Maybe<String>;
	rollNumber_not_contains?: Maybe<String>;
	rollNumber_starts_with?: Maybe<String>;
	rollNumber_not_starts_with?: Maybe<String>;
	rollNumber_ends_with?: Maybe<String>;
	rollNumber_not_ends_with?: Maybe<String>;
	email?: Maybe<String>;
	email_not?: Maybe<String>;
	email_in?: Maybe<String[] | String>;
	email_not_in?: Maybe<String[] | String>;
	email_lt?: Maybe<String>;
	email_lte?: Maybe<String>;
	email_gt?: Maybe<String>;
	email_gte?: Maybe<String>;
	email_contains?: Maybe<String>;
	email_not_contains?: Maybe<String>;
	email_starts_with?: Maybe<String>;
	email_not_starts_with?: Maybe<String>;
	email_ends_with?: Maybe<String>;
	email_not_ends_with?: Maybe<String>;
	mobile?: Maybe<String>;
	mobile_not?: Maybe<String>;
	mobile_in?: Maybe<String[] | String>;
	mobile_not_in?: Maybe<String[] | String>;
	mobile_lt?: Maybe<String>;
	mobile_lte?: Maybe<String>;
	mobile_gt?: Maybe<String>;
	mobile_gte?: Maybe<String>;
	mobile_contains?: Maybe<String>;
	mobile_not_contains?: Maybe<String>;
	mobile_starts_with?: Maybe<String>;
	mobile_not_starts_with?: Maybe<String>;
	mobile_ends_with?: Maybe<String>;
	mobile_not_ends_with?: Maybe<String>;
	upi?: Maybe<String>;
	upi_not?: Maybe<String>;
	upi_in?: Maybe<String[] | String>;
	upi_not_in?: Maybe<String[] | String>;
	upi_lt?: Maybe<String>;
	upi_lte?: Maybe<String>;
	upi_gt?: Maybe<String>;
	upi_gte?: Maybe<String>;
	upi_contains?: Maybe<String>;
	upi_not_contains?: Maybe<String>;
	upi_starts_with?: Maybe<String>;
	upi_not_starts_with?: Maybe<String>;
	upi_ends_with?: Maybe<String>;
	upi_not_ends_with?: Maybe<String>;
	profilePic?: Maybe<String>;
	profilePic_not?: Maybe<String>;
	profilePic_in?: Maybe<String[] | String>;
	profilePic_not_in?: Maybe<String[] | String>;
	profilePic_lt?: Maybe<String>;
	profilePic_lte?: Maybe<String>;
	profilePic_gt?: Maybe<String>;
	profilePic_gte?: Maybe<String>;
	profilePic_contains?: Maybe<String>;
	profilePic_not_contains?: Maybe<String>;
	profilePic_starts_with?: Maybe<String>;
	profilePic_not_starts_with?: Maybe<String>;
	profilePic_ends_with?: Maybe<String>;
	profilePic_not_ends_with?: Maybe<String>;
	coverPic?: Maybe<String>;
	coverPic_not?: Maybe<String>;
	coverPic_in?: Maybe<String[] | String>;
	coverPic_not_in?: Maybe<String[] | String>;
	coverPic_lt?: Maybe<String>;
	coverPic_lte?: Maybe<String>;
	coverPic_gt?: Maybe<String>;
	coverPic_gte?: Maybe<String>;
	coverPic_contains?: Maybe<String>;
	coverPic_not_contains?: Maybe<String>;
	coverPic_starts_with?: Maybe<String>;
	coverPic_not_starts_with?: Maybe<String>;
	coverPic_ends_with?: Maybe<String>;
	coverPic_not_ends_with?: Maybe<String>;
	role?: Maybe<AccessLevel>;
	role_not?: Maybe<AccessLevel>;
	role_in?: Maybe<AccessLevel[] | AccessLevel>;
	role_not_in?: Maybe<AccessLevel[] | AccessLevel>;
	department?: Maybe<DepartmentWhereInput>;
	channels_every?: Maybe<ChannelWhereInput>;
	channels_some?: Maybe<ChannelWhereInput>;
	channels_none?: Maybe<ChannelWhereInput>;
	messages_every?: Maybe<MessageWhereInput>;
	messages_some?: Maybe<MessageWhereInput>;
	messages_none?: Maybe<MessageWhereInput>;
	AND?: Maybe<UserWhereInput[] | UserWhereInput>;
	OR?: Maybe<UserWhereInput[] | UserWhereInput>;
	NOT?: Maybe<UserWhereInput[] | UserWhereInput>;
}

export interface DepartmentWhereInput {
	id?: Maybe<ID_Input>;
	id_not?: Maybe<ID_Input>;
	id_in?: Maybe<ID_Input[] | ID_Input>;
	id_not_in?: Maybe<ID_Input[] | ID_Input>;
	id_lt?: Maybe<ID_Input>;
	id_lte?: Maybe<ID_Input>;
	id_gt?: Maybe<ID_Input>;
	id_gte?: Maybe<ID_Input>;
	id_contains?: Maybe<ID_Input>;
	id_not_contains?: Maybe<ID_Input>;
	id_starts_with?: Maybe<ID_Input>;
	id_not_starts_with?: Maybe<ID_Input>;
	id_ends_with?: Maybe<ID_Input>;
	id_not_ends_with?: Maybe<ID_Input>;
	name?: Maybe<String>;
	name_not?: Maybe<String>;
	name_in?: Maybe<String[] | String>;
	name_not_in?: Maybe<String[] | String>;
	name_lt?: Maybe<String>;
	name_lte?: Maybe<String>;
	name_gt?: Maybe<String>;
	name_gte?: Maybe<String>;
	name_contains?: Maybe<String>;
	name_not_contains?: Maybe<String>;
	name_starts_with?: Maybe<String>;
	name_not_starts_with?: Maybe<String>;
	name_ends_with?: Maybe<String>;
	name_not_ends_with?: Maybe<String>;
	members_every?: Maybe<UserWhereInput>;
	members_some?: Maybe<UserWhereInput>;
	members_none?: Maybe<UserWhereInput>;
	AND?: Maybe<DepartmentWhereInput[] | DepartmentWhereInput>;
	OR?: Maybe<DepartmentWhereInput[] | DepartmentWhereInput>;
	NOT?: Maybe<DepartmentWhereInput[] | DepartmentWhereInput>;
}

export interface ChannelWhereInput {
	id?: Maybe<ID_Input>;
	id_not?: Maybe<ID_Input>;
	id_in?: Maybe<ID_Input[] | ID_Input>;
	id_not_in?: Maybe<ID_Input[] | ID_Input>;
	id_lt?: Maybe<ID_Input>;
	id_lte?: Maybe<ID_Input>;
	id_gt?: Maybe<ID_Input>;
	id_gte?: Maybe<ID_Input>;
	id_contains?: Maybe<ID_Input>;
	id_not_contains?: Maybe<ID_Input>;
	id_starts_with?: Maybe<ID_Input>;
	id_not_starts_with?: Maybe<ID_Input>;
	id_ends_with?: Maybe<ID_Input>;
	id_not_ends_with?: Maybe<ID_Input>;
	name?: Maybe<String>;
	name_not?: Maybe<String>;
	name_in?: Maybe<String[] | String>;
	name_not_in?: Maybe<String[] | String>;
	name_lt?: Maybe<String>;
	name_lte?: Maybe<String>;
	name_gt?: Maybe<String>;
	name_gte?: Maybe<String>;
	name_contains?: Maybe<String>;
	name_not_contains?: Maybe<String>;
	name_starts_with?: Maybe<String>;
	name_not_starts_with?: Maybe<String>;
	name_ends_with?: Maybe<String>;
	name_not_ends_with?: Maybe<String>;
	members_every?: Maybe<UserWhereInput>;
	members_some?: Maybe<UserWhereInput>;
	members_none?: Maybe<UserWhereInput>;
	messages_every?: Maybe<MessageWhereInput>;
	messages_some?: Maybe<MessageWhereInput>;
	messages_none?: Maybe<MessageWhereInput>;
	createdAt?: Maybe<DateTimeInput>;
	createdAt_not?: Maybe<DateTimeInput>;
	createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
	createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
	createdAt_lt?: Maybe<DateTimeInput>;
	createdAt_lte?: Maybe<DateTimeInput>;
	createdAt_gt?: Maybe<DateTimeInput>;
	createdAt_gte?: Maybe<DateTimeInput>;
	AND?: Maybe<ChannelWhereInput[] | ChannelWhereInput>;
	OR?: Maybe<ChannelWhereInput[] | ChannelWhereInput>;
	NOT?: Maybe<ChannelWhereInput[] | ChannelWhereInput>;
}

export interface MessageWhereInput {
	id?: Maybe<ID_Input>;
	id_not?: Maybe<ID_Input>;
	id_in?: Maybe<ID_Input[] | ID_Input>;
	id_not_in?: Maybe<ID_Input[] | ID_Input>;
	id_lt?: Maybe<ID_Input>;
	id_lte?: Maybe<ID_Input>;
	id_gt?: Maybe<ID_Input>;
	id_gte?: Maybe<ID_Input>;
	id_contains?: Maybe<ID_Input>;
	id_not_contains?: Maybe<ID_Input>;
	id_starts_with?: Maybe<ID_Input>;
	id_not_starts_with?: Maybe<ID_Input>;
	id_ends_with?: Maybe<ID_Input>;
	id_not_ends_with?: Maybe<ID_Input>;
	content?: Maybe<String>;
	content_not?: Maybe<String>;
	content_in?: Maybe<String[] | String>;
	content_not_in?: Maybe<String[] | String>;
	content_lt?: Maybe<String>;
	content_lte?: Maybe<String>;
	content_gt?: Maybe<String>;
	content_gte?: Maybe<String>;
	content_contains?: Maybe<String>;
	content_not_contains?: Maybe<String>;
	content_starts_with?: Maybe<String>;
	content_not_starts_with?: Maybe<String>;
	content_ends_with?: Maybe<String>;
	content_not_ends_with?: Maybe<String>;
	by?: Maybe<UserWhereInput>;
	channel?: Maybe<ChannelWhereInput>;
	createdAt?: Maybe<DateTimeInput>;
	createdAt_not?: Maybe<DateTimeInput>;
	createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
	createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
	createdAt_lt?: Maybe<DateTimeInput>;
	createdAt_lte?: Maybe<DateTimeInput>;
	createdAt_gt?: Maybe<DateTimeInput>;
	createdAt_gte?: Maybe<DateTimeInput>;
	AND?: Maybe<MessageWhereInput[] | MessageWhereInput>;
	OR?: Maybe<MessageWhereInput[] | MessageWhereInput>;
	NOT?: Maybe<MessageWhereInput[] | MessageWhereInput>;
}

export type DepartmentWhereUniqueInput = AtLeastOne<{
	id: Maybe<ID_Input>;
}>;

export type MessageWhereUniqueInput = AtLeastOne<{
	id: Maybe<ID_Input>;
}>;

export type UserWhereUniqueInput = AtLeastOne<{
	id: Maybe<ID_Input>;
	rollNumber?: Maybe<String>;
	email?: Maybe<String>;
	mobile?: Maybe<String>;
}>;

export interface ChannelCreateInput {
	id?: Maybe<ID_Input>;
	name: String;
	members?: Maybe<UserCreateManyWithoutChannelsInput>;
	messages?: Maybe<MessageCreateManyWithoutChannelInput>;
}

export interface UserCreateManyWithoutChannelsInput {
	create?: Maybe<UserCreateWithoutChannelsInput[] | UserCreateWithoutChannelsInput>;
	connect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
}

export interface UserCreateWithoutChannelsInput {
	id?: Maybe<ID_Input>;
	name: String;
	rollNumber: String;
	email: String;
	mobile: String;
	upi: String;
	profilePic: String;
	coverPic: String;
	role?: Maybe<AccessLevel>;
	department?: Maybe<DepartmentCreateOneWithoutMembersInput>;
	messages?: Maybe<MessageCreateManyWithoutByInput>;
}

export interface DepartmentCreateOneWithoutMembersInput {
	create?: Maybe<DepartmentCreateWithoutMembersInput>;
	connect?: Maybe<DepartmentWhereUniqueInput>;
}

export interface DepartmentCreateWithoutMembersInput {
	id?: Maybe<ID_Input>;
	name: String;
	subDepartments?: Maybe<DepartmentCreatesubDepartmentsInput>;
}

export interface DepartmentCreatesubDepartmentsInput {
	set?: Maybe<String[] | String>;
}

export interface MessageCreateManyWithoutByInput {
	create?: Maybe<MessageCreateWithoutByInput[] | MessageCreateWithoutByInput>;
	connect?: Maybe<MessageWhereUniqueInput[] | MessageWhereUniqueInput>;
}

export interface MessageCreateWithoutByInput {
	id?: Maybe<ID_Input>;
	content: String;
	channel: ChannelCreateOneWithoutMessagesInput;
}

export interface ChannelCreateOneWithoutMessagesInput {
	create?: Maybe<ChannelCreateWithoutMessagesInput>;
	connect?: Maybe<ChannelWhereUniqueInput>;
}

export interface ChannelCreateWithoutMessagesInput {
	id?: Maybe<ID_Input>;
	name: String;
	members?: Maybe<UserCreateManyWithoutChannelsInput>;
}

export interface MessageCreateManyWithoutChannelInput {
	create?: Maybe<MessageCreateWithoutChannelInput[] | MessageCreateWithoutChannelInput>;
	connect?: Maybe<MessageWhereUniqueInput[] | MessageWhereUniqueInput>;
}

export interface MessageCreateWithoutChannelInput {
	id?: Maybe<ID_Input>;
	content: String;
	by: UserCreateOneWithoutMessagesInput;
}

export interface UserCreateOneWithoutMessagesInput {
	create?: Maybe<UserCreateWithoutMessagesInput>;
	connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserCreateWithoutMessagesInput {
	id?: Maybe<ID_Input>;
	name: String;
	rollNumber: String;
	email: String;
	mobile: String;
	upi: String;
	profilePic: String;
	coverPic: String;
	role?: Maybe<AccessLevel>;
	department?: Maybe<DepartmentCreateOneWithoutMembersInput>;
	channels?: Maybe<ChannelCreateManyWithoutMembersInput>;
}

export interface ChannelCreateManyWithoutMembersInput {
	create?: Maybe<ChannelCreateWithoutMembersInput[] | ChannelCreateWithoutMembersInput>;
	connect?: Maybe<ChannelWhereUniqueInput[] | ChannelWhereUniqueInput>;
}

export interface ChannelCreateWithoutMembersInput {
	id?: Maybe<ID_Input>;
	name: String;
	messages?: Maybe<MessageCreateManyWithoutChannelInput>;
}

export interface ChannelUpdateInput {
	name?: Maybe<String>;
	members?: Maybe<UserUpdateManyWithoutChannelsInput>;
	messages?: Maybe<MessageUpdateManyWithoutChannelInput>;
}

export interface UserUpdateManyWithoutChannelsInput {
	create?: Maybe<UserCreateWithoutChannelsInput[] | UserCreateWithoutChannelsInput>;
	delete?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
	connect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
	set?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
	disconnect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
	update?: Maybe<| UserUpdateWithWhereUniqueWithoutChannelsInput[]
		| UserUpdateWithWhereUniqueWithoutChannelsInput>;
	upsert?: Maybe<| UserUpsertWithWhereUniqueWithoutChannelsInput[]
		| UserUpsertWithWhereUniqueWithoutChannelsInput>;
	deleteMany?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
	updateMany?: Maybe<UserUpdateManyWithWhereNestedInput[] | UserUpdateManyWithWhereNestedInput>;
}

export interface UserUpdateWithWhereUniqueWithoutChannelsInput {
	where: UserWhereUniqueInput;
	data: UserUpdateWithoutChannelsDataInput;
}

export interface UserUpdateWithoutChannelsDataInput {
	name?: Maybe<String>;
	rollNumber?: Maybe<String>;
	email?: Maybe<String>;
	mobile?: Maybe<String>;
	upi?: Maybe<String>;
	profilePic?: Maybe<String>;
	coverPic?: Maybe<String>;
	role?: Maybe<AccessLevel>;
	department?: Maybe<DepartmentUpdateOneWithoutMembersInput>;
	messages?: Maybe<MessageUpdateManyWithoutByInput>;
}

export interface DepartmentUpdateOneWithoutMembersInput {
	create?: Maybe<DepartmentCreateWithoutMembersInput>;
	update?: Maybe<DepartmentUpdateWithoutMembersDataInput>;
	upsert?: Maybe<DepartmentUpsertWithoutMembersInput>;
	delete?: Maybe<Boolean>;
	disconnect?: Maybe<Boolean>;
	connect?: Maybe<DepartmentWhereUniqueInput>;
}

export interface DepartmentUpdateWithoutMembersDataInput {
	name?: Maybe<String>;
	subDepartments?: Maybe<DepartmentUpdatesubDepartmentsInput>;
}

export interface DepartmentUpdatesubDepartmentsInput {
	set?: Maybe<String[] | String>;
}

export interface DepartmentUpsertWithoutMembersInput {
	update: DepartmentUpdateWithoutMembersDataInput;
	create: DepartmentCreateWithoutMembersInput;
}

export interface MessageUpdateManyWithoutByInput {
	create?: Maybe<MessageCreateWithoutByInput[] | MessageCreateWithoutByInput>;
	delete?: Maybe<MessageWhereUniqueInput[] | MessageWhereUniqueInput>;
	connect?: Maybe<MessageWhereUniqueInput[] | MessageWhereUniqueInput>;
	set?: Maybe<MessageWhereUniqueInput[] | MessageWhereUniqueInput>;
	disconnect?: Maybe<MessageWhereUniqueInput[] | MessageWhereUniqueInput>;
	update?: Maybe<| MessageUpdateWithWhereUniqueWithoutByInput[]
		| MessageUpdateWithWhereUniqueWithoutByInput>;
	upsert?: Maybe<| MessageUpsertWithWhereUniqueWithoutByInput[]
		| MessageUpsertWithWhereUniqueWithoutByInput>;
	deleteMany?: Maybe<MessageScalarWhereInput[] | MessageScalarWhereInput>;
	updateMany?: Maybe<| MessageUpdateManyWithWhereNestedInput[]
		| MessageUpdateManyWithWhereNestedInput>;
}

export interface MessageUpdateWithWhereUniqueWithoutByInput {
	where: MessageWhereUniqueInput;
	data: MessageUpdateWithoutByDataInput;
}

export interface MessageUpdateWithoutByDataInput {
	content?: Maybe<String>;
	channel?: Maybe<ChannelUpdateOneRequiredWithoutMessagesInput>;
}

export interface ChannelUpdateOneRequiredWithoutMessagesInput {
	create?: Maybe<ChannelCreateWithoutMessagesInput>;
	update?: Maybe<ChannelUpdateWithoutMessagesDataInput>;
	upsert?: Maybe<ChannelUpsertWithoutMessagesInput>;
	connect?: Maybe<ChannelWhereUniqueInput>;
}

export interface ChannelUpdateWithoutMessagesDataInput {
	name?: Maybe<String>;
	members?: Maybe<UserUpdateManyWithoutChannelsInput>;
}

export interface ChannelUpsertWithoutMessagesInput {
	update: ChannelUpdateWithoutMessagesDataInput;
	create: ChannelCreateWithoutMessagesInput;
}

export interface MessageUpsertWithWhereUniqueWithoutByInput {
	where: MessageWhereUniqueInput;
	update: MessageUpdateWithoutByDataInput;
	create: MessageCreateWithoutByInput;
}

export interface MessageScalarWhereInput {
	id?: Maybe<ID_Input>;
	id_not?: Maybe<ID_Input>;
	id_in?: Maybe<ID_Input[] | ID_Input>;
	id_not_in?: Maybe<ID_Input[] | ID_Input>;
	id_lt?: Maybe<ID_Input>;
	id_lte?: Maybe<ID_Input>;
	id_gt?: Maybe<ID_Input>;
	id_gte?: Maybe<ID_Input>;
	id_contains?: Maybe<ID_Input>;
	id_not_contains?: Maybe<ID_Input>;
	id_starts_with?: Maybe<ID_Input>;
	id_not_starts_with?: Maybe<ID_Input>;
	id_ends_with?: Maybe<ID_Input>;
	id_not_ends_with?: Maybe<ID_Input>;
	content?: Maybe<String>;
	content_not?: Maybe<String>;
	content_in?: Maybe<String[] | String>;
	content_not_in?: Maybe<String[] | String>;
	content_lt?: Maybe<String>;
	content_lte?: Maybe<String>;
	content_gt?: Maybe<String>;
	content_gte?: Maybe<String>;
	content_contains?: Maybe<String>;
	content_not_contains?: Maybe<String>;
	content_starts_with?: Maybe<String>;
	content_not_starts_with?: Maybe<String>;
	content_ends_with?: Maybe<String>;
	content_not_ends_with?: Maybe<String>;
	createdAt?: Maybe<DateTimeInput>;
	createdAt_not?: Maybe<DateTimeInput>;
	createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
	createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
	createdAt_lt?: Maybe<DateTimeInput>;
	createdAt_lte?: Maybe<DateTimeInput>;
	createdAt_gt?: Maybe<DateTimeInput>;
	createdAt_gte?: Maybe<DateTimeInput>;
	AND?: Maybe<MessageScalarWhereInput[] | MessageScalarWhereInput>;
	OR?: Maybe<MessageScalarWhereInput[] | MessageScalarWhereInput>;
	NOT?: Maybe<MessageScalarWhereInput[] | MessageScalarWhereInput>;
}

export interface MessageUpdateManyWithWhereNestedInput {
	where: MessageScalarWhereInput;
	data: MessageUpdateManyDataInput;
}

export interface MessageUpdateManyDataInput {
	content?: Maybe<String>;
}

export interface UserUpsertWithWhereUniqueWithoutChannelsInput {
	where: UserWhereUniqueInput;
	update: UserUpdateWithoutChannelsDataInput;
	create: UserCreateWithoutChannelsInput;
}

export interface UserScalarWhereInput {
	id?: Maybe<ID_Input>;
	id_not?: Maybe<ID_Input>;
	id_in?: Maybe<ID_Input[] | ID_Input>;
	id_not_in?: Maybe<ID_Input[] | ID_Input>;
	id_lt?: Maybe<ID_Input>;
	id_lte?: Maybe<ID_Input>;
	id_gt?: Maybe<ID_Input>;
	id_gte?: Maybe<ID_Input>;
	id_contains?: Maybe<ID_Input>;
	id_not_contains?: Maybe<ID_Input>;
	id_starts_with?: Maybe<ID_Input>;
	id_not_starts_with?: Maybe<ID_Input>;
	id_ends_with?: Maybe<ID_Input>;
	id_not_ends_with?: Maybe<ID_Input>;
	name?: Maybe<String>;
	name_not?: Maybe<String>;
	name_in?: Maybe<String[] | String>;
	name_not_in?: Maybe<String[] | String>;
	name_lt?: Maybe<String>;
	name_lte?: Maybe<String>;
	name_gt?: Maybe<String>;
	name_gte?: Maybe<String>;
	name_contains?: Maybe<String>;
	name_not_contains?: Maybe<String>;
	name_starts_with?: Maybe<String>;
	name_not_starts_with?: Maybe<String>;
	name_ends_with?: Maybe<String>;
	name_not_ends_with?: Maybe<String>;
	rollNumber?: Maybe<String>;
	rollNumber_not?: Maybe<String>;
	rollNumber_in?: Maybe<String[] | String>;
	rollNumber_not_in?: Maybe<String[] | String>;
	rollNumber_lt?: Maybe<String>;
	rollNumber_lte?: Maybe<String>;
	rollNumber_gt?: Maybe<String>;
	rollNumber_gte?: Maybe<String>;
	rollNumber_contains?: Maybe<String>;
	rollNumber_not_contains?: Maybe<String>;
	rollNumber_starts_with?: Maybe<String>;
	rollNumber_not_starts_with?: Maybe<String>;
	rollNumber_ends_with?: Maybe<String>;
	rollNumber_not_ends_with?: Maybe<String>;
	email?: Maybe<String>;
	email_not?: Maybe<String>;
	email_in?: Maybe<String[] | String>;
	email_not_in?: Maybe<String[] | String>;
	email_lt?: Maybe<String>;
	email_lte?: Maybe<String>;
	email_gt?: Maybe<String>;
	email_gte?: Maybe<String>;
	email_contains?: Maybe<String>;
	email_not_contains?: Maybe<String>;
	email_starts_with?: Maybe<String>;
	email_not_starts_with?: Maybe<String>;
	email_ends_with?: Maybe<String>;
	email_not_ends_with?: Maybe<String>;
	mobile?: Maybe<String>;
	mobile_not?: Maybe<String>;
	mobile_in?: Maybe<String[] | String>;
	mobile_not_in?: Maybe<String[] | String>;
	mobile_lt?: Maybe<String>;
	mobile_lte?: Maybe<String>;
	mobile_gt?: Maybe<String>;
	mobile_gte?: Maybe<String>;
	mobile_contains?: Maybe<String>;
	mobile_not_contains?: Maybe<String>;
	mobile_starts_with?: Maybe<String>;
	mobile_not_starts_with?: Maybe<String>;
	mobile_ends_with?: Maybe<String>;
	mobile_not_ends_with?: Maybe<String>;
	upi?: Maybe<String>;
	upi_not?: Maybe<String>;
	upi_in?: Maybe<String[] | String>;
	upi_not_in?: Maybe<String[] | String>;
	upi_lt?: Maybe<String>;
	upi_lte?: Maybe<String>;
	upi_gt?: Maybe<String>;
	upi_gte?: Maybe<String>;
	upi_contains?: Maybe<String>;
	upi_not_contains?: Maybe<String>;
	upi_starts_with?: Maybe<String>;
	upi_not_starts_with?: Maybe<String>;
	upi_ends_with?: Maybe<String>;
	upi_not_ends_with?: Maybe<String>;
	profilePic?: Maybe<String>;
	profilePic_not?: Maybe<String>;
	profilePic_in?: Maybe<String[] | String>;
	profilePic_not_in?: Maybe<String[] | String>;
	profilePic_lt?: Maybe<String>;
	profilePic_lte?: Maybe<String>;
	profilePic_gt?: Maybe<String>;
	profilePic_gte?: Maybe<String>;
	profilePic_contains?: Maybe<String>;
	profilePic_not_contains?: Maybe<String>;
	profilePic_starts_with?: Maybe<String>;
	profilePic_not_starts_with?: Maybe<String>;
	profilePic_ends_with?: Maybe<String>;
	profilePic_not_ends_with?: Maybe<String>;
	coverPic?: Maybe<String>;
	coverPic_not?: Maybe<String>;
	coverPic_in?: Maybe<String[] | String>;
	coverPic_not_in?: Maybe<String[] | String>;
	coverPic_lt?: Maybe<String>;
	coverPic_lte?: Maybe<String>;
	coverPic_gt?: Maybe<String>;
	coverPic_gte?: Maybe<String>;
	coverPic_contains?: Maybe<String>;
	coverPic_not_contains?: Maybe<String>;
	coverPic_starts_with?: Maybe<String>;
	coverPic_not_starts_with?: Maybe<String>;
	coverPic_ends_with?: Maybe<String>;
	coverPic_not_ends_with?: Maybe<String>;
	role?: Maybe<AccessLevel>;
	role_not?: Maybe<AccessLevel>;
	role_in?: Maybe<AccessLevel[] | AccessLevel>;
	role_not_in?: Maybe<AccessLevel[] | AccessLevel>;
	AND?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
	OR?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
	NOT?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
}

export interface UserUpdateManyWithWhereNestedInput {
	where: UserScalarWhereInput;
	data: UserUpdateManyDataInput;
}

export interface UserUpdateManyDataInput {
	name?: Maybe<String>;
	rollNumber?: Maybe<String>;
	email?: Maybe<String>;
	mobile?: Maybe<String>;
	upi?: Maybe<String>;
	profilePic?: Maybe<String>;
	coverPic?: Maybe<String>;
	role?: Maybe<AccessLevel>;
}

export interface MessageUpdateManyWithoutChannelInput {
	create?: Maybe<MessageCreateWithoutChannelInput[] | MessageCreateWithoutChannelInput>;
	delete?: Maybe<MessageWhereUniqueInput[] | MessageWhereUniqueInput>;
	connect?: Maybe<MessageWhereUniqueInput[] | MessageWhereUniqueInput>;
	set?: Maybe<MessageWhereUniqueInput[] | MessageWhereUniqueInput>;
	disconnect?: Maybe<MessageWhereUniqueInput[] | MessageWhereUniqueInput>;
	update?: Maybe<| MessageUpdateWithWhereUniqueWithoutChannelInput[]
		| MessageUpdateWithWhereUniqueWithoutChannelInput>;
	upsert?: Maybe<| MessageUpsertWithWhereUniqueWithoutChannelInput[]
		| MessageUpsertWithWhereUniqueWithoutChannelInput>;
	deleteMany?: Maybe<MessageScalarWhereInput[] | MessageScalarWhereInput>;
	updateMany?: Maybe<| MessageUpdateManyWithWhereNestedInput[]
		| MessageUpdateManyWithWhereNestedInput>;
}

export interface MessageUpdateWithWhereUniqueWithoutChannelInput {
	where: MessageWhereUniqueInput;
	data: MessageUpdateWithoutChannelDataInput;
}

export interface MessageUpdateWithoutChannelDataInput {
	content?: Maybe<String>;
	by?: Maybe<UserUpdateOneRequiredWithoutMessagesInput>;
}

export interface UserUpdateOneRequiredWithoutMessagesInput {
	create?: Maybe<UserCreateWithoutMessagesInput>;
	update?: Maybe<UserUpdateWithoutMessagesDataInput>;
	upsert?: Maybe<UserUpsertWithoutMessagesInput>;
	connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserUpdateWithoutMessagesDataInput {
	name?: Maybe<String>;
	rollNumber?: Maybe<String>;
	email?: Maybe<String>;
	mobile?: Maybe<String>;
	upi?: Maybe<String>;
	profilePic?: Maybe<String>;
	coverPic?: Maybe<String>;
	role?: Maybe<AccessLevel>;
	department?: Maybe<DepartmentUpdateOneWithoutMembersInput>;
	channels?: Maybe<ChannelUpdateManyWithoutMembersInput>;
}

export interface ChannelUpdateManyWithoutMembersInput {
	create?: Maybe<ChannelCreateWithoutMembersInput[] | ChannelCreateWithoutMembersInput>;
	delete?: Maybe<ChannelWhereUniqueInput[] | ChannelWhereUniqueInput>;
	connect?: Maybe<ChannelWhereUniqueInput[] | ChannelWhereUniqueInput>;
	set?: Maybe<ChannelWhereUniqueInput[] | ChannelWhereUniqueInput>;
	disconnect?: Maybe<ChannelWhereUniqueInput[] | ChannelWhereUniqueInput>;
	update?: Maybe<| ChannelUpdateWithWhereUniqueWithoutMembersInput[]
		| ChannelUpdateWithWhereUniqueWithoutMembersInput>;
	upsert?: Maybe<| ChannelUpsertWithWhereUniqueWithoutMembersInput[]
		| ChannelUpsertWithWhereUniqueWithoutMembersInput>;
	deleteMany?: Maybe<ChannelScalarWhereInput[] | ChannelScalarWhereInput>;
	updateMany?: Maybe<| ChannelUpdateManyWithWhereNestedInput[]
		| ChannelUpdateManyWithWhereNestedInput>;
}

export interface ChannelUpdateWithWhereUniqueWithoutMembersInput {
	where: ChannelWhereUniqueInput;
	data: ChannelUpdateWithoutMembersDataInput;
}

export interface ChannelUpdateWithoutMembersDataInput {
	name?: Maybe<String>;
	messages?: Maybe<MessageUpdateManyWithoutChannelInput>;
}

export interface ChannelUpsertWithWhereUniqueWithoutMembersInput {
	where: ChannelWhereUniqueInput;
	update: ChannelUpdateWithoutMembersDataInput;
	create: ChannelCreateWithoutMembersInput;
}

export interface ChannelScalarWhereInput {
	id?: Maybe<ID_Input>;
	id_not?: Maybe<ID_Input>;
	id_in?: Maybe<ID_Input[] | ID_Input>;
	id_not_in?: Maybe<ID_Input[] | ID_Input>;
	id_lt?: Maybe<ID_Input>;
	id_lte?: Maybe<ID_Input>;
	id_gt?: Maybe<ID_Input>;
	id_gte?: Maybe<ID_Input>;
	id_contains?: Maybe<ID_Input>;
	id_not_contains?: Maybe<ID_Input>;
	id_starts_with?: Maybe<ID_Input>;
	id_not_starts_with?: Maybe<ID_Input>;
	id_ends_with?: Maybe<ID_Input>;
	id_not_ends_with?: Maybe<ID_Input>;
	name?: Maybe<String>;
	name_not?: Maybe<String>;
	name_in?: Maybe<String[] | String>;
	name_not_in?: Maybe<String[] | String>;
	name_lt?: Maybe<String>;
	name_lte?: Maybe<String>;
	name_gt?: Maybe<String>;
	name_gte?: Maybe<String>;
	name_contains?: Maybe<String>;
	name_not_contains?: Maybe<String>;
	name_starts_with?: Maybe<String>;
	name_not_starts_with?: Maybe<String>;
	name_ends_with?: Maybe<String>;
	name_not_ends_with?: Maybe<String>;
	createdAt?: Maybe<DateTimeInput>;
	createdAt_not?: Maybe<DateTimeInput>;
	createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
	createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
	createdAt_lt?: Maybe<DateTimeInput>;
	createdAt_lte?: Maybe<DateTimeInput>;
	createdAt_gt?: Maybe<DateTimeInput>;
	createdAt_gte?: Maybe<DateTimeInput>;
	AND?: Maybe<ChannelScalarWhereInput[] | ChannelScalarWhereInput>;
	OR?: Maybe<ChannelScalarWhereInput[] | ChannelScalarWhereInput>;
	NOT?: Maybe<ChannelScalarWhereInput[] | ChannelScalarWhereInput>;
}

export interface ChannelUpdateManyWithWhereNestedInput {
	where: ChannelScalarWhereInput;
	data: ChannelUpdateManyDataInput;
}

export interface ChannelUpdateManyDataInput {
	name?: Maybe<String>;
}

export interface UserUpsertWithoutMessagesInput {
	update: UserUpdateWithoutMessagesDataInput;
	create: UserCreateWithoutMessagesInput;
}

export interface MessageUpsertWithWhereUniqueWithoutChannelInput {
	where: MessageWhereUniqueInput;
	update: MessageUpdateWithoutChannelDataInput;
	create: MessageCreateWithoutChannelInput;
}

export interface ChannelUpdateManyMutationInput {
	name?: Maybe<String>;
}

export interface DepartmentCreateInput {
	id?: Maybe<ID_Input>;
	name: String;
	subDepartments?: Maybe<DepartmentCreatesubDepartmentsInput>;
	members?: Maybe<UserCreateManyWithoutDepartmentInput>;
}

export interface UserCreateManyWithoutDepartmentInput {
	create?: Maybe<UserCreateWithoutDepartmentInput[] | UserCreateWithoutDepartmentInput>;
	connect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
}

export interface UserCreateWithoutDepartmentInput {
	id?: Maybe<ID_Input>;
	name: String;
	rollNumber: String;
	email: String;
	mobile: String;
	upi: String;
	profilePic: String;
	coverPic: String;
	role?: Maybe<AccessLevel>;
	channels?: Maybe<ChannelCreateManyWithoutMembersInput>;
	messages?: Maybe<MessageCreateManyWithoutByInput>;
}

export interface DepartmentUpdateInput {
	name?: Maybe<String>;
	subDepartments?: Maybe<DepartmentUpdatesubDepartmentsInput>;
	members?: Maybe<UserUpdateManyWithoutDepartmentInput>;
}

export interface UserUpdateManyWithoutDepartmentInput {
	create?: Maybe<UserCreateWithoutDepartmentInput[] | UserCreateWithoutDepartmentInput>;
	delete?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
	connect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
	set?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
	disconnect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
	update?: Maybe<| UserUpdateWithWhereUniqueWithoutDepartmentInput[]
		| UserUpdateWithWhereUniqueWithoutDepartmentInput>;
	upsert?: Maybe<| UserUpsertWithWhereUniqueWithoutDepartmentInput[]
		| UserUpsertWithWhereUniqueWithoutDepartmentInput>;
	deleteMany?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
	updateMany?: Maybe<UserUpdateManyWithWhereNestedInput[] | UserUpdateManyWithWhereNestedInput>;
}

export interface UserUpdateWithWhereUniqueWithoutDepartmentInput {
	where: UserWhereUniqueInput;
	data: UserUpdateWithoutDepartmentDataInput;
}

export interface UserUpdateWithoutDepartmentDataInput {
	name?: Maybe<String>;
	rollNumber?: Maybe<String>;
	email?: Maybe<String>;
	mobile?: Maybe<String>;
	upi?: Maybe<String>;
	profilePic?: Maybe<String>;
	coverPic?: Maybe<String>;
	role?: Maybe<AccessLevel>;
	channels?: Maybe<ChannelUpdateManyWithoutMembersInput>;
	messages?: Maybe<MessageUpdateManyWithoutByInput>;
}

export interface UserUpsertWithWhereUniqueWithoutDepartmentInput {
	where: UserWhereUniqueInput;
	update: UserUpdateWithoutDepartmentDataInput;
	create: UserCreateWithoutDepartmentInput;
}

export interface DepartmentUpdateManyMutationInput {
	name?: Maybe<String>;
	subDepartments?: Maybe<DepartmentUpdatesubDepartmentsInput>;
}

export interface MessageCreateInput {
	id?: Maybe<ID_Input>;
	content: String;
	by: UserCreateOneWithoutMessagesInput;
	channel: ChannelCreateOneWithoutMessagesInput;
}

export interface MessageUpdateInput {
	content?: Maybe<String>;
	by?: Maybe<UserUpdateOneRequiredWithoutMessagesInput>;
	channel?: Maybe<ChannelUpdateOneRequiredWithoutMessagesInput>;
}

export interface MessageUpdateManyMutationInput {
	content?: Maybe<String>;
}

export interface UserCreateInput {
	id?: Maybe<ID_Input>;
	name: String;
	rollNumber: String;
	email: String;
	mobile: String;
	upi: String;
	profilePic: String;
	coverPic: String;
	role?: Maybe<AccessLevel>;
	department?: Maybe<DepartmentCreateOneWithoutMembersInput>;
	channels?: Maybe<ChannelCreateManyWithoutMembersInput>;
	messages?: Maybe<MessageCreateManyWithoutByInput>;
}

export interface UserUpdateInput {
	name?: Maybe<String>;
	rollNumber?: Maybe<String>;
	email?: Maybe<String>;
	mobile?: Maybe<String>;
	upi?: Maybe<String>;
	profilePic?: Maybe<String>;
	coverPic?: Maybe<String>;
	role?: Maybe<AccessLevel>;
	department?: Maybe<DepartmentUpdateOneWithoutMembersInput>;
	channels?: Maybe<ChannelUpdateManyWithoutMembersInput>;
	messages?: Maybe<MessageUpdateManyWithoutByInput>;
}

export interface UserUpdateManyMutationInput {
	name?: Maybe<String>;
	rollNumber?: Maybe<String>;
	email?: Maybe<String>;
	mobile?: Maybe<String>;
	upi?: Maybe<String>;
	profilePic?: Maybe<String>;
	coverPic?: Maybe<String>;
	role?: Maybe<AccessLevel>;
}

export interface ChannelSubscriptionWhereInput {
	mutation_in?: Maybe<MutationType[] | MutationType>;
	updatedFields_contains?: Maybe<String>;
	updatedFields_contains_every?: Maybe<String[] | String>;
	updatedFields_contains_some?: Maybe<String[] | String>;
	node?: Maybe<ChannelWhereInput>;
	AND?: Maybe<ChannelSubscriptionWhereInput[] | ChannelSubscriptionWhereInput>;
	OR?: Maybe<ChannelSubscriptionWhereInput[] | ChannelSubscriptionWhereInput>;
	NOT?: Maybe<ChannelSubscriptionWhereInput[] | ChannelSubscriptionWhereInput>;
}

export interface DepartmentSubscriptionWhereInput {
	mutation_in?: Maybe<MutationType[] | MutationType>;
	updatedFields_contains?: Maybe<String>;
	updatedFields_contains_every?: Maybe<String[] | String>;
	updatedFields_contains_some?: Maybe<String[] | String>;
	node?: Maybe<DepartmentWhereInput>;
	AND?: Maybe<DepartmentSubscriptionWhereInput[] | DepartmentSubscriptionWhereInput>;
	OR?: Maybe<DepartmentSubscriptionWhereInput[] | DepartmentSubscriptionWhereInput>;
	NOT?: Maybe<DepartmentSubscriptionWhereInput[] | DepartmentSubscriptionWhereInput>;
}

export interface MessageSubscriptionWhereInput {
	mutation_in?: Maybe<MutationType[] | MutationType>;
	updatedFields_contains?: Maybe<String>;
	updatedFields_contains_every?: Maybe<String[] | String>;
	updatedFields_contains_some?: Maybe<String[] | String>;
	node?: Maybe<MessageWhereInput>;
	AND?: Maybe<MessageSubscriptionWhereInput[] | MessageSubscriptionWhereInput>;
	OR?: Maybe<MessageSubscriptionWhereInput[] | MessageSubscriptionWhereInput>;
	NOT?: Maybe<MessageSubscriptionWhereInput[] | MessageSubscriptionWhereInput>;
}

export interface UserSubscriptionWhereInput {
	mutation_in?: Maybe<MutationType[] | MutationType>;
	updatedFields_contains?: Maybe<String>;
	updatedFields_contains_every?: Maybe<String[] | String>;
	updatedFields_contains_some?: Maybe<String[] | String>;
	node?: Maybe<UserWhereInput>;
	AND?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
	OR?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
	NOT?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
}

export interface NodeNode {
	id: ID_Output;
}

export interface Channel {
	id: ID_Output;
	name: String;
	createdAt: DateTimeOutput;
}

export interface ChannelPromise extends Promise<Channel>, Fragmentable {
	id: () => Promise<ID_Output>;
	name: () => Promise<String>;
	members: <T = FragmentableArray<User>>( args?: {
		where?: UserWhereInput;
		orderBy?: UserOrderByInput;
		skip?: Int;
		after?: String;
		before?: String;
		first?: Int;
		last?: Int;
	} ) => T;
	messages: <T = FragmentableArray<Message>>( args?: {
		where?: MessageWhereInput;
		orderBy?: MessageOrderByInput;
		skip?: Int;
		after?: String;
		before?: String;
		first?: Int;
		last?: Int;
	} ) => T;
	createdAt: () => Promise<DateTimeOutput>;
}

export interface ChannelSubscription
	extends Promise<AsyncIterator<Channel>>,
		Fragmentable {
	id: () => Promise<AsyncIterator<ID_Output>>;
	name: () => Promise<AsyncIterator<String>>;
	members: <T = Promise<AsyncIterator<UserSubscription>>>( args?: {
		where?: UserWhereInput;
		orderBy?: UserOrderByInput;
		skip?: Int;
		after?: String;
		before?: String;
		first?: Int;
		last?: Int;
	} ) => T;
	messages: <T = Promise<AsyncIterator<MessageSubscription>>>( args?: {
		where?: MessageWhereInput;
		orderBy?: MessageOrderByInput;
		skip?: Int;
		after?: String;
		before?: String;
		first?: Int;
		last?: Int;
	} ) => T;
	createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ChannelNullablePromise
	extends Promise<Channel | null>,
		Fragmentable {
	id: () => Promise<ID_Output>;
	name: () => Promise<String>;
	members: <T = FragmentableArray<User>>( args?: {
		where?: UserWhereInput;
		orderBy?: UserOrderByInput;
		skip?: Int;
		after?: String;
		before?: String;
		first?: Int;
		last?: Int;
	} ) => T;
	messages: <T = FragmentableArray<Message>>( args?: {
		where?: MessageWhereInput;
		orderBy?: MessageOrderByInput;
		skip?: Int;
		after?: String;
		before?: String;
		first?: Int;
		last?: Int;
	} ) => T;
	createdAt: () => Promise<DateTimeOutput>;
}

export interface User {
	id: ID_Output;
	name: String;
	rollNumber: String;
	email: String;
	mobile: String;
	upi: String;
	profilePic: String;
	coverPic: String;
	role: AccessLevel;
}

export interface UserPromise extends Promise<User>, Fragmentable {
	id: () => Promise<ID_Output>;
	name: () => Promise<String>;
	rollNumber: () => Promise<String>;
	email: () => Promise<String>;
	mobile: () => Promise<String>;
	upi: () => Promise<String>;
	profilePic: () => Promise<String>;
	coverPic: () => Promise<String>;
	role: () => Promise<AccessLevel>;
	department: <T = DepartmentPromise>() => T;
	channels: <T = FragmentableArray<Channel>>( args?: {
		where?: ChannelWhereInput;
		orderBy?: ChannelOrderByInput;
		skip?: Int;
		after?: String;
		before?: String;
		first?: Int;
		last?: Int;
	} ) => T;
	messages: <T = FragmentableArray<Message>>( args?: {
		where?: MessageWhereInput;
		orderBy?: MessageOrderByInput;
		skip?: Int;
		after?: String;
		before?: String;
		first?: Int;
		last?: Int;
	} ) => T;
}

export interface UserSubscription
	extends Promise<AsyncIterator<User>>,
		Fragmentable {
	id: () => Promise<AsyncIterator<ID_Output>>;
	name: () => Promise<AsyncIterator<String>>;
	rollNumber: () => Promise<AsyncIterator<String>>;
	email: () => Promise<AsyncIterator<String>>;
	mobile: () => Promise<AsyncIterator<String>>;
	upi: () => Promise<AsyncIterator<String>>;
	profilePic: () => Promise<AsyncIterator<String>>;
	coverPic: () => Promise<AsyncIterator<String>>;
	role: () => Promise<AsyncIterator<AccessLevel>>;
	department: <T = DepartmentSubscription>() => T;
	channels: <T = Promise<AsyncIterator<ChannelSubscription>>>( args?: {
		where?: ChannelWhereInput;
		orderBy?: ChannelOrderByInput;
		skip?: Int;
		after?: String;
		before?: String;
		first?: Int;
		last?: Int;
	} ) => T;
	messages: <T = Promise<AsyncIterator<MessageSubscription>>>( args?: {
		where?: MessageWhereInput;
		orderBy?: MessageOrderByInput;
		skip?: Int;
		after?: String;
		before?: String;
		first?: Int;
		last?: Int;
	} ) => T;
}

export interface UserNullablePromise
	extends Promise<User | null>,
		Fragmentable {
	id: () => Promise<ID_Output>;
	name: () => Promise<String>;
	rollNumber: () => Promise<String>;
	email: () => Promise<String>;
	mobile: () => Promise<String>;
	upi: () => Promise<String>;
	profilePic: () => Promise<String>;
	coverPic: () => Promise<String>;
	role: () => Promise<AccessLevel>;
	department: <T = DepartmentPromise>() => T;
	channels: <T = FragmentableArray<Channel>>( args?: {
		where?: ChannelWhereInput;
		orderBy?: ChannelOrderByInput;
		skip?: Int;
		after?: String;
		before?: String;
		first?: Int;
		last?: Int;
	} ) => T;
	messages: <T = FragmentableArray<Message>>( args?: {
		where?: MessageWhereInput;
		orderBy?: MessageOrderByInput;
		skip?: Int;
		after?: String;
		before?: String;
		first?: Int;
		last?: Int;
	} ) => T;
}

export interface Department {
	id: ID_Output;
	name: String;
	subDepartments: String[];
}

export interface DepartmentPromise extends Promise<Department>, Fragmentable {
	id: () => Promise<ID_Output>;
	name: () => Promise<String>;
	subDepartments: () => Promise<String[]>;
	members: <T = FragmentableArray<User>>( args?: {
		where?: UserWhereInput;
		orderBy?: UserOrderByInput;
		skip?: Int;
		after?: String;
		before?: String;
		first?: Int;
		last?: Int;
	} ) => T;
}

export interface DepartmentSubscription
	extends Promise<AsyncIterator<Department>>,
		Fragmentable {
	id: () => Promise<AsyncIterator<ID_Output>>;
	name: () => Promise<AsyncIterator<String>>;
	subDepartments: () => Promise<AsyncIterator<String[]>>;
	members: <T = Promise<AsyncIterator<UserSubscription>>>( args?: {
		where?: UserWhereInput;
		orderBy?: UserOrderByInput;
		skip?: Int;
		after?: String;
		before?: String;
		first?: Int;
		last?: Int;
	} ) => T;
}

export interface DepartmentNullablePromise
	extends Promise<Department | null>,
		Fragmentable {
	id: () => Promise<ID_Output>;
	name: () => Promise<String>;
	subDepartments: () => Promise<String[]>;
	members: <T = FragmentableArray<User>>( args?: {
		where?: UserWhereInput;
		orderBy?: UserOrderByInput;
		skip?: Int;
		after?: String;
		before?: String;
		first?: Int;
		last?: Int;
	} ) => T;
}

export interface Message {
	id: ID_Output;
	content: String;
	createdAt: DateTimeOutput;
}

export interface MessagePromise extends Promise<Message>, Fragmentable {
	id: () => Promise<ID_Output>;
	content: () => Promise<String>;
	by: <T = UserPromise>() => T;
	channel: <T = ChannelPromise>() => T;
	createdAt: () => Promise<DateTimeOutput>;
}

export interface MessageSubscription
	extends Promise<AsyncIterator<Message>>,
		Fragmentable {
	id: () => Promise<AsyncIterator<ID_Output>>;
	content: () => Promise<AsyncIterator<String>>;
	by: <T = UserSubscription>() => T;
	channel: <T = ChannelSubscription>() => T;
	createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface MessageNullablePromise
	extends Promise<Message | null>,
		Fragmentable {
	id: () => Promise<ID_Output>;
	content: () => Promise<String>;
	by: <T = UserPromise>() => T;
	channel: <T = ChannelPromise>() => T;
	createdAt: () => Promise<DateTimeOutput>;
}

export interface ChannelConnection {
	pageInfo: PageInfo;
	edges: ChannelEdge[];
}

export interface ChannelConnectionPromise
	extends Promise<ChannelConnection>,
		Fragmentable {
	pageInfo: <T = PageInfoPromise>() => T;
	edges: <T = FragmentableArray<ChannelEdge>>() => T;
	aggregate: <T = AggregateChannelPromise>() => T;
}

export interface ChannelConnectionSubscription
	extends Promise<AsyncIterator<ChannelConnection>>,
		Fragmentable {
	pageInfo: <T = PageInfoSubscription>() => T;
	edges: <T = Promise<AsyncIterator<ChannelEdgeSubscription>>>() => T;
	aggregate: <T = AggregateChannelSubscription>() => T;
}

export interface PageInfo {
	hasNextPage: Boolean;
	hasPreviousPage: Boolean;
	startCursor?: String;
	endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
	hasNextPage: () => Promise<Boolean>;
	hasPreviousPage: () => Promise<Boolean>;
	startCursor: () => Promise<String>;
	endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
	extends Promise<AsyncIterator<PageInfo>>,
		Fragmentable {
	hasNextPage: () => Promise<AsyncIterator<Boolean>>;
	hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
	startCursor: () => Promise<AsyncIterator<String>>;
	endCursor: () => Promise<AsyncIterator<String>>;
}

export interface ChannelEdge {
	node: Channel;
	cursor: String;
}

export interface ChannelEdgePromise extends Promise<ChannelEdge>, Fragmentable {
	node: <T = ChannelPromise>() => T;
	cursor: () => Promise<String>;
}

export interface ChannelEdgeSubscription
	extends Promise<AsyncIterator<ChannelEdge>>,
		Fragmentable {
	node: <T = ChannelSubscription>() => T;
	cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateChannel {
	count: Int;
}

export interface AggregateChannelPromise
	extends Promise<AggregateChannel>,
		Fragmentable {
	count: () => Promise<Int>;
}

export interface AggregateChannelSubscription
	extends Promise<AsyncIterator<AggregateChannel>>,
		Fragmentable {
	count: () => Promise<AsyncIterator<Int>>;
}

export interface DepartmentConnection {
	pageInfo: PageInfo;
	edges: DepartmentEdge[];
}

export interface DepartmentConnectionPromise
	extends Promise<DepartmentConnection>,
		Fragmentable {
	pageInfo: <T = PageInfoPromise>() => T;
	edges: <T = FragmentableArray<DepartmentEdge>>() => T;
	aggregate: <T = AggregateDepartmentPromise>() => T;
}

export interface DepartmentConnectionSubscription
	extends Promise<AsyncIterator<DepartmentConnection>>,
		Fragmentable {
	pageInfo: <T = PageInfoSubscription>() => T;
	edges: <T = Promise<AsyncIterator<DepartmentEdgeSubscription>>>() => T;
	aggregate: <T = AggregateDepartmentSubscription>() => T;
}

export interface DepartmentEdge {
	node: Department;
	cursor: String;
}

export interface DepartmentEdgePromise
	extends Promise<DepartmentEdge>,
		Fragmentable {
	node: <T = DepartmentPromise>() => T;
	cursor: () => Promise<String>;
}

export interface DepartmentEdgeSubscription
	extends Promise<AsyncIterator<DepartmentEdge>>,
		Fragmentable {
	node: <T = DepartmentSubscription>() => T;
	cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateDepartment {
	count: Int;
}

export interface AggregateDepartmentPromise
	extends Promise<AggregateDepartment>,
		Fragmentable {
	count: () => Promise<Int>;
}

export interface AggregateDepartmentSubscription
	extends Promise<AsyncIterator<AggregateDepartment>>,
		Fragmentable {
	count: () => Promise<AsyncIterator<Int>>;
}

export interface MessageConnection {
	pageInfo: PageInfo;
	edges: MessageEdge[];
}

export interface MessageConnectionPromise
	extends Promise<MessageConnection>,
		Fragmentable {
	pageInfo: <T = PageInfoPromise>() => T;
	edges: <T = FragmentableArray<MessageEdge>>() => T;
	aggregate: <T = AggregateMessagePromise>() => T;
}

export interface MessageConnectionSubscription
	extends Promise<AsyncIterator<MessageConnection>>,
		Fragmentable {
	pageInfo: <T = PageInfoSubscription>() => T;
	edges: <T = Promise<AsyncIterator<MessageEdgeSubscription>>>() => T;
	aggregate: <T = AggregateMessageSubscription>() => T;
}

export interface MessageEdge {
	node: Message;
	cursor: String;
}

export interface MessageEdgePromise extends Promise<MessageEdge>, Fragmentable {
	node: <T = MessagePromise>() => T;
	cursor: () => Promise<String>;
}

export interface MessageEdgeSubscription
	extends Promise<AsyncIterator<MessageEdge>>,
		Fragmentable {
	node: <T = MessageSubscription>() => T;
	cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateMessage {
	count: Int;
}

export interface AggregateMessagePromise
	extends Promise<AggregateMessage>,
		Fragmentable {
	count: () => Promise<Int>;
}

export interface AggregateMessageSubscription
	extends Promise<AsyncIterator<AggregateMessage>>,
		Fragmentable {
	count: () => Promise<AsyncIterator<Int>>;
}

export interface UserConnection {
	pageInfo: PageInfo;
	edges: UserEdge[];
}

export interface UserConnectionPromise
	extends Promise<UserConnection>,
		Fragmentable {
	pageInfo: <T = PageInfoPromise>() => T;
	edges: <T = FragmentableArray<UserEdge>>() => T;
	aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
	extends Promise<AsyncIterator<UserConnection>>,
		Fragmentable {
	pageInfo: <T = PageInfoSubscription>() => T;
	edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
	aggregate: <T = AggregateUserSubscription>() => T;
}

export interface UserEdge {
	node: User;
	cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
	node: <T = UserPromise>() => T;
	cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
	extends Promise<AsyncIterator<UserEdge>>,
		Fragmentable {
	node: <T = UserSubscription>() => T;
	cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateUser {
	count: Int;
}

export interface AggregateUserPromise
	extends Promise<AggregateUser>,
		Fragmentable {
	count: () => Promise<Int>;
}

export interface AggregateUserSubscription
	extends Promise<AsyncIterator<AggregateUser>>,
		Fragmentable {
	count: () => Promise<AsyncIterator<Int>>;
}

export interface BatchPayload {
	count: Long;
}

export interface BatchPayloadPromise
	extends Promise<BatchPayload>,
		Fragmentable {
	count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
	extends Promise<AsyncIterator<BatchPayload>>,
		Fragmentable {
	count: () => Promise<AsyncIterator<Long>>;
}

export interface ChannelSubscriptionPayload {
	mutation: MutationType;
	node: Channel;
	updatedFields: String[];
	previousValues: ChannelPreviousValues;
}

export interface ChannelSubscriptionPayloadPromise
	extends Promise<ChannelSubscriptionPayload>,
		Fragmentable {
	mutation: () => Promise<MutationType>;
	node: <T = ChannelPromise>() => T;
	updatedFields: () => Promise<String[]>;
	previousValues: <T = ChannelPreviousValuesPromise>() => T;
}

export interface ChannelSubscriptionPayloadSubscription
	extends Promise<AsyncIterator<ChannelSubscriptionPayload>>,
		Fragmentable {
	mutation: () => Promise<AsyncIterator<MutationType>>;
	node: <T = ChannelSubscription>() => T;
	updatedFields: () => Promise<AsyncIterator<String[]>>;
	previousValues: <T = ChannelPreviousValuesSubscription>() => T;
}

export interface ChannelPreviousValues {
	id: ID_Output;
	name: String;
	createdAt: DateTimeOutput;
}

export interface ChannelPreviousValuesPromise
	extends Promise<ChannelPreviousValues>,
		Fragmentable {
	id: () => Promise<ID_Output>;
	name: () => Promise<String>;
	createdAt: () => Promise<DateTimeOutput>;
}

export interface ChannelPreviousValuesSubscription
	extends Promise<AsyncIterator<ChannelPreviousValues>>,
		Fragmentable {
	id: () => Promise<AsyncIterator<ID_Output>>;
	name: () => Promise<AsyncIterator<String>>;
	createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface DepartmentSubscriptionPayload {
	mutation: MutationType;
	node: Department;
	updatedFields: String[];
	previousValues: DepartmentPreviousValues;
}

export interface DepartmentSubscriptionPayloadPromise
	extends Promise<DepartmentSubscriptionPayload>,
		Fragmentable {
	mutation: () => Promise<MutationType>;
	node: <T = DepartmentPromise>() => T;
	updatedFields: () => Promise<String[]>;
	previousValues: <T = DepartmentPreviousValuesPromise>() => T;
}

export interface DepartmentSubscriptionPayloadSubscription
	extends Promise<AsyncIterator<DepartmentSubscriptionPayload>>,
		Fragmentable {
	mutation: () => Promise<AsyncIterator<MutationType>>;
	node: <T = DepartmentSubscription>() => T;
	updatedFields: () => Promise<AsyncIterator<String[]>>;
	previousValues: <T = DepartmentPreviousValuesSubscription>() => T;
}

export interface DepartmentPreviousValues {
	id: ID_Output;
	name: String;
	subDepartments: String[];
}

export interface DepartmentPreviousValuesPromise
	extends Promise<DepartmentPreviousValues>,
		Fragmentable {
	id: () => Promise<ID_Output>;
	name: () => Promise<String>;
	subDepartments: () => Promise<String[]>;
}

export interface DepartmentPreviousValuesSubscription
	extends Promise<AsyncIterator<DepartmentPreviousValues>>,
		Fragmentable {
	id: () => Promise<AsyncIterator<ID_Output>>;
	name: () => Promise<AsyncIterator<String>>;
	subDepartments: () => Promise<AsyncIterator<String[]>>;
}

export interface MessageSubscriptionPayload {
	mutation: MutationType;
	node: Message;
	updatedFields: String[];
	previousValues: MessagePreviousValues;
}

export interface MessageSubscriptionPayloadPromise
	extends Promise<MessageSubscriptionPayload>,
		Fragmentable {
	mutation: () => Promise<MutationType>;
	node: <T = MessagePromise>() => T;
	updatedFields: () => Promise<String[]>;
	previousValues: <T = MessagePreviousValuesPromise>() => T;
}

export interface MessageSubscriptionPayloadSubscription
	extends Promise<AsyncIterator<MessageSubscriptionPayload>>,
		Fragmentable {
	mutation: () => Promise<AsyncIterator<MutationType>>;
	node: <T = MessageSubscription>() => T;
	updatedFields: () => Promise<AsyncIterator<String[]>>;
	previousValues: <T = MessagePreviousValuesSubscription>() => T;
}

export interface MessagePreviousValues {
	id: ID_Output;
	content: String;
	createdAt: DateTimeOutput;
}

export interface MessagePreviousValuesPromise
	extends Promise<MessagePreviousValues>,
		Fragmentable {
	id: () => Promise<ID_Output>;
	content: () => Promise<String>;
	createdAt: () => Promise<DateTimeOutput>;
}

export interface MessagePreviousValuesSubscription
	extends Promise<AsyncIterator<MessagePreviousValues>>,
		Fragmentable {
	id: () => Promise<AsyncIterator<ID_Output>>;
	content: () => Promise<AsyncIterator<String>>;
	createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface UserSubscriptionPayload {
	mutation: MutationType;
	node: User;
	updatedFields: String[];
	previousValues: UserPreviousValues;
}

export interface UserSubscriptionPayloadPromise
	extends Promise<UserSubscriptionPayload>,
		Fragmentable {
	mutation: () => Promise<MutationType>;
	node: <T = UserPromise>() => T;
	updatedFields: () => Promise<String[]>;
	previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
	extends Promise<AsyncIterator<UserSubscriptionPayload>>,
		Fragmentable {
	mutation: () => Promise<AsyncIterator<MutationType>>;
	node: <T = UserSubscription>() => T;
	updatedFields: () => Promise<AsyncIterator<String[]>>;
	previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface UserPreviousValues {
	id: ID_Output;
	name: String;
	rollNumber: String;
	email: String;
	mobile: String;
	upi: String;
	profilePic: String;
	coverPic: String;
	role: AccessLevel;
}

export interface UserPreviousValuesPromise
	extends Promise<UserPreviousValues>,
		Fragmentable {
	id: () => Promise<ID_Output>;
	name: () => Promise<String>;
	rollNumber: () => Promise<String>;
	email: () => Promise<String>;
	mobile: () => Promise<String>;
	upi: () => Promise<String>;
	profilePic: () => Promise<String>;
	coverPic: () => Promise<String>;
	role: () => Promise<AccessLevel>;
}

export interface UserPreviousValuesSubscription
	extends Promise<AsyncIterator<UserPreviousValues>>,
		Fragmentable {
	id: () => Promise<AsyncIterator<ID_Output>>;
	name: () => Promise<AsyncIterator<String>>;
	rollNumber: () => Promise<AsyncIterator<String>>;
	email: () => Promise<AsyncIterator<String>>;
	mobile: () => Promise<AsyncIterator<String>>;
	upi: () => Promise<AsyncIterator<String>>;
	profilePic: () => Promise<AsyncIterator<String>>;
	coverPic: () => Promise<AsyncIterator<String>>;
	role: () => Promise<AsyncIterator<AccessLevel>>;
}

/*
 The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
 */
export type ID_Input = string | number;
export type ID_Output = string;

/*
 The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
 */
export type String = string;

/*
 DateTime scalar input type, allowing Date
 */
export type DateTimeInput = Date | string;

/*
 DateTime scalar output type, which is always a string
 */
export type DateTimeOutput = string;

/*
 The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.
 */
export type Int = number;

/*
 The `Boolean` scalar type represents `true` or `false`.
 */
export type Boolean = boolean;

export type Long = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
	{
		name : "AccessLevel",
		embedded : false
	},
	{
		name : "User",
		embedded : false
	},
	{
		name : "Department",
		embedded : false
	},
	{
		name : "Channel",
		embedded : false
	},
	{
		name : "Message",
		embedded : false
	}
];

/**
 * Type Defs
 */

export const Prisma = makePrismaClientClass<ClientConstructor<Prisma>>( {
	typeDefs,
	models,
	endpoint : `${ process.env["PRISMA_ENDPOINT"] }`,
	secret : `${ process.env["PRISMA_SERVICE_SECRET"] }`
} );
export const prisma = new Prisma();
